{"./":{"url":"./","title":"Code an OS Project","keywords":"","body":"Code an OS Project 这个文档记录了这个实验与教学性质的操作系统的开发完善过程（当然不包含一些曾经使用过但后来弃用的一些内容）。我们希望这个文档足够详细，让有兴趣的同学可以参照这个文档一步一步完整地实现一个一样的操作系统，甚至在此基础上有所改进。 这份文档所对应的代码都可以在 LZU-OSLab/lzu_oslab: A simple OS running on RISC-V for education 中找到。 本教程最主要用到的参考资料是 RISC-V Reader Chinese v2.1 小知识有时候文档里会出现此类带有小知识标题的引用块，只是做一些相关的介绍，感兴趣的同学可以看一看作为补充知识，不了解也不影响相关任务。 本网站使用 Gitbook 创建，开源在 Github 上，使用 Github Actions 自动构建，在线阅读链接：https://doc.rvos.dev/ By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"ready/":{"url":"ready/","title":"准备","keywords":"","body":"准备 工欲善其事，必先利其器。在这一章我们会准备好敲代码、测试和调试的整个环境。 敲代码的工具自然是可以自由选择，作为这个文档的编写者我推荐使用 Visual Studio Code ，微软开发的跨平台编辑器，装上几个插件可以说是非常好用了。 运行的环境自然也是可以选择自己喜欢的环境，我比较喜欢 Ubuntu 系的发行版，因此环境配置说明我就选择了基于 Ubuntu 平台的配置方法，其他的 Linux 发行版也可以自由选择，不要太古老就好，比如 Kong Jun 大佬喜欢使用他的 Fedora) 系统。另外喜欢使用 Windows 的同学更推荐使用 WSL。 小知识：适用于 Linux 的 Windows 子系统（Windows Subsystem for Linux，WSL） 适用于 Linux 的 Windows 子系统（即 WSL）可让开发人员按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生传统虚拟机或双启动设置开销。WSL 2 是适用于 Linux 的 Windows 子系统体系结构的一个新版本，它支持适用于 Linux 的 Windows 子系统在 Windows 上运行 ELF64 Linux 二进制文件。 它的主要目标是提高文件系统性能，以及添加完全的系统调用兼容性。—— 关于适用于 Linux 的 Windows 子系统 | Microsoft Docs注：上文中提到的 GNU/Linux 就是 Linux 简单来说，Windows 和 Linux 的运行环境、系统调用、可执行文件的格式等都是不同的，对于习惯于 Windows 系统使用的我们来说，偶尔要使用一次 Linux，装一个 Linux 系统或者建一个 Linux 虚拟机似乎没有很大的必要，就可以使用 WSL 在 Windows 下运行 Linux 的程序——没错，我们的项目所用到的都是 Linux 下的程序。 那么，下面就让我们开始吧。 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"ready/intro.html":{"url":"ready/intro.html","title":"总体介绍","keywords":"","body":"总体介绍 RISC-V 硬件指令集架构千千万，我们选择 64 位 RISC-V，无他，只是因为这个项目开始时老师推荐使用罢了（笑 不过最后体验下来 RISC-V 确实是非常优秀的一套指令集架构，相信我，如果你和我一样一步步来完成了这个操作系统，你也会爱上 RISC-V 的简洁高效。 先来简单介绍一下 RISC-V，这是一个与 x86 有相当大的区别的开源 RISC 指令集，由加州伯克利和校外的几位大佬共同开发，项目始于 2010 年，因此是个非常年轻的指令集架构，没有很多的历史包袱，一切从简，并且根据已有的指令集架构的优点和不足做了很多的改进，因此是一个非常“摩登”的指令集架构。它采用模块化设计，64 位的 RISC-V 基本指令集称为 RV64I（这里的 I 代表整数的意思，即这是一个 64 位的基本整数指令集），在此基础上可以扩展不同的指令集（如乘法、单双精度浮点的支持等），详细可见 RISC-V 维基百科。 RISC-V 作为精简指令集 (reduced instruction set computer，RISC)，有大多数精简指令集架构都有的一大特性：通用寄存器（没有特殊用途可被任意使用的寄存器）非常多。在汇编代码层面与传统 x86 这类复杂指令集 (Complex Instruction Set Computer，CISC) 的汇编语言也有很大的不同，比如没有入栈出栈的汇编语句，当然入栈和出栈的操作还是有的，但这就需要我们使用访存指令和栈指针的寄存器的加减来实现此类操作。具体指令当我们需要用到时会再介绍。 小知识：精简指令集计算机 (reduced instruction set computer，RISC) 精简指令集计算机（英语：reduced instruction set computer，缩写：RISC）或简译为精简指令集，是计算机中央处理器的一种设计模式。这种设计思路可以想像成是一家模块化的组装工厂，对指令数目和寻址方式都做了精简，使其实现更容易，指令并行执行程度更好，编译器的效率更高。目前常见的精简指令集微处理器包括 ARM、MIPS、RISC-V 和 SPARC 等。—— 精简指令集计算机 - 维基百科，自由的百科全书 指令集的每一条指令的实现都需要花费芯片的一部分面积，精简指令集的一大思想就是只保留最常用的和不可缺少的指令，其余功能通过指令组合来实现，这样指令的译码、执行等所占用的芯片面积较少，在同样的面积下可以比复杂指令集放下更多的通用寄存器（如 RISC-V 有 32 个通用寄存器）以减少内存访问，加快速度（访问速度：寄存器 > Cache >> 内存）。   存储器层次结构 存储器从上到下速度降低，价格降低，容量提升。寄存器是封装在 CPU 核心内部的临时存储器，与 CPU 距离最近，速度最快，容量最小，价格最贵。 RISC-V 处理器通常有 3 个特权级，由高到底分别为 M 模式（machine mode）、S 模式（supervisor mode）和 U 模式（user mode）。M 模式下运行最受信任的代码，S 模式下运行操作系统，U 模式下运行用户程序。M 模式下的代码对整个系统拥有绝对控制权，可以控制一切硬件资源。 Supervisor 二进制接口（SBI） RISC-V 标准还规定了一套 Supervisor 二进制接口（SBI），它运行于 M 模式，掌控着整台计算机，你可以认为它是 RISC-V 上的 BIOS（BIOS 又可以看作是最底层的直接接触硬件的一个基本操作系统），它提供了一些环境调用的支持，对更底层的硬件做了一部分的抽象和封装。一般来说，操作系统都不会直接管理硬件资源，而是会通过环境调用来让 SBI 协助管理。 SBI，或者 Supervisor Binary Interface，是操作系统向底层（虚拟层、中间件、固件等等）提出服务请求的接口。 从优先级来说，也就是 S 模式下的程序向 M(H) 模式的服务程序提出请求的 API 接口。从软件体系来说，操作系统通过 SBI 向底层硬件提出服务请求，某种程度上 SBI 为操作系统提供了针对底层硬件的隔离。 —— CNRV 双周简报（2018-12-11）- 技术讨论 - 让我们重新思考 SBI 的定义 ( archive.is 互联网存档 )（写的不错，建议阅读，了解一下当初讨论的几种思想） SBI 只是一个规范，根据这个规范，不同的厂家（或程序员）可以编写不同的 SBI 程序，一个完整的符合 SBI 规范的程序称为 SBI 实现（下面简称 SBI ），RISC-V 官方做了一个 SBI 实现，叫 OpenSBI，此外还有其他的 SBI 实现，如 BBL、RustSBI 等。SBI 是一个刷写在主板上的程序。 操作系统作为一个程序，必须加载到内存里才能执行。而“把操作系统加载到内存里”这件事情，不是操作系统自己能做到的，就好像你不能拽着头发把自己拽离地面。 因此我们可以想象，在操作系统执行之前，必然有一个其他程序执行，他作为“先锋队”，完成“把操作系统加载到内存“这个工作，然后他功成身退，把 CPU 的控制权交给操作系统。 这个“其他程序”，我们一般称之为 bootloader。很好理解：他负责 boot（开机），还负责 load（加载 OS 到内存里），所以叫 bootloader。 —— 内存布局，OpenSBI，elf 和 bin - ucore step by step 在 RISC-V 中，这个 bootloader 就是 SBI，或者更确切地说，充当 bootloader 就是 SBI 的一部分功能。 计算机的启动顺序：上电 -> 运行 SBI -> SBI 加载运行操作系统 -> 操作系统加载普通用户程序 如果还是不明白 SBI 是什么，没有关系，具体是什么可能不重要，它能干什么后面也会讲到，不用担心，这并不影响后续的学习。 GCC 没错，我们使用 GCC，我们使用 C 语言（虽然 GCC 已经能编译很多其他语言了），因为大学期间我们学得最早也用得比较熟练的操作系统编程语言就是 C 语言了，其余的底层（可直接控制内存）编程语言如 Rust 语言在大学课程里出现比较罕见，自学的学习曲线也比较陡峭（就是说很难入门），因此我们还是选择比较传统且“落后”的 C 语言。 这里我们使用的 GCC 不是一般的 GCC，而是可以在 x86 架构下编译出 RISC-V 代码的交叉编译器。 交叉编译 在解释什么是交叉编译之前，先要明白什么是本地编译。 本地编译可以理解为，在当前编译平台下，编译出来的程序只能放到当前平台下运行。平时我们常见的软件开发，都是属于本地编译：比如，我们在 x86 平台上，编写程序并编译成可执行程序。这种方式下，我们使用 x86 平台上的工具，开发针对 x86 平台本身的可执行程序，这个编译过程称为本地编译。 交叉编译可以理解为，在当前编译平台下，编译出来的程序能运行在体系结构不同的另一种目标平台上，但是编译平台本身却不能运行该程序：比如，我们在 x86 平台上，编写程序并编译成能运行在 ARM 平台的程序，编译得到的程序在 x86 平台上是不能运行的，必须放到 ARM 平台上才能运行。 之所以要有交叉编译，主要原因是： Speed： 目标平台的运行速度往往比主机慢得多，许多专用的嵌入式硬件被设计为低成本和低功耗，没有太高的性能Capability： 整个编译过程是非常消耗资源的，嵌入式系统往往没有足够的内存或磁盘空间Availability： 即使目标平台资源很充足，可以本地编译，但是第一个在目标平台上运行的本地编译器总需要通过交叉编译获得Flexibility： 一个完整的 Linux 编译环境需要很多支持包，交叉编译使我们不需要花时间将各种支持包移植到目标板上—— 什么是交叉编译_whatday 的专栏   小知识：GCC GNU 编译器套装（英语：GNU Compiler Collection，缩写为 GCC），指一套编程语言编译器，是 GNU 工具链的主要组成部分之一。GCC（特别是其中的 C 语言编译器）也常被认为是跨平台编译器的事实标准。 原名为 GNU C 语言编译器（GNU C Compiler），因为它原本只能处理 C 语言。GCC 在发布后很快地得到扩展，变得可处理 C++。之后也变得可处理 Fortran、Pascal、Objective-C、Java、Ada，Go 与其他语言。 许多操作系统，包括许多类 Unix 系统，如 Linux 及 BSD 家族都采用 GCC 作为标准编译器。 —— GCC - 维基百科，自由的百科全书 GDB 既然用了 GCC，那就用配套的调试平台 GDB 吧，没有什么其他的原因。 小知识：GDB GNU 调试器（英语：GNU Debugger，缩写：GDB），是 GNU 软件系统中的标准调试器，此外 GDB 也是个具有移携性的调试器，经过移携需求的调修与重新编译，如今许多的类 UNIX 操作系统上都可以使用 GDB，而现有 GDB 所能支持调试的编程语言有 C、C++、Pascal 以及 FORTRAN。 —— GNU 调试器 - 维基百科，自由的百科全书   小知识：GNU 工具链 GNU 工具链（英语：GNU toolchain）是一个包含了由 GNU 计划所产生的各种编程工具的集合，由自由软件基金会负责维护工作。这些工具形成了一条工具链，用于开发应用程序和操作系统。 组成（加粗部分是我们会使用到的）：GNU make：用于编译和构建的自动工具GNU 编译器集合（GCC）：一组多种编程语言的编译器GNU Binutils：包含链接器、汇编器和其它工具的工具集GNU Bison: 编译器编译程序，经常和 Flex 词法分析器 配合使用GNU m4： m4 宏预处理器GNU Debugger（GDB）：代码调试工具GNU 构建系统（autotools） —— GNU 工具链 - 维基百科，自由的百科全书 QEMU QEMU 是一个很棒的模拟器，可以通过动态的二进制转换，模拟 CPU，因此能够让我们在 x86 的电脑上模拟出 RISC-V 的运行环境，便于我们的开发测试，还可以和 GDB 联动调试，非常方便。我们的系统很小很简单，因此也完全不需要考虑性能之类的问题，只要能跑起来就可以了。 QEMU 所模拟的 64 位 RISC-V 指令集支持到了 RV64ACDFIMSU。 RV64ACDFIMSU： 原子指令 (A) 压缩指令 (C) 双精度浮点运算 (D) 单精度浮点运算 (F) 整数运算 (RV64I) 整数乘除法 (M) 特权级 M 模式（machine mode） S 模式（supervisor mode） U 模式（user mode） QEMU 自带 OpenSBI，但因为有问题，启动后寻址不正确，因此我们使用 OpenSBI 的官方 v0.9 版本，配合 OpenSBI 官方仓库打包好的固件即可。 若不指定参数，模拟 RISC-V 环境的 QEMU virt 虚拟机的默认物理内存大小为 128 MiB，我们就采用这个大小，不做修改。 参考资料 理解 SBI： riscv-sbi-doc: SBI 规范。后续我们会封装其中一部分 ecall 调用（环境调用）。 理解 RISC-V 指令集和汇编语言： RISC-V Assembly Language：RISC-V 官方的汇编语言教程。篇幅很短，都是例子，需要有 RISC-V 指令的基础。 RISC-V Reader（中译版）：完整的 RISC-V 教程，包括主要的指令集拓展和汇编语言。该书假设读者有计算机组成原理、体系结构的知识，了解至少一种指令集，有使用汇编语言编程的经验。 《计算机组成与设计-硬件/软件接口（原书第 5 版）》：RISC-V 的两位主要设计者撰写的教材。第二章介绍 RISC-V 指令，并使用 RISC-V 指令编程。该书假设读者没有任何关于计算机组成原理和汇编语言的知识。 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"ready/env.html":{"url":"ready/env.html","title":"环境部署","keywords":"","body":"环境部署 这里我们主要安装几个上篇介绍过的开发环境，这里主要介绍 Ubuntu 环境下的配置安装过程，在 Ubuntu 18.04.5 LTS 以及 Ubuntu 20.04 LTS 上测试通过，其余发行版请根据自身情况安装相应软件包。 首先我们先来安装几个必要的软件包，其中一部分是用于编译 QEMU 和 GDB 的，这里也顺带安装了 git、tmux、gcc-riscv64-linux-gnu 等工具，其中gcc-riscv64-linux-gnu就是我们所用的交叉编译器。 sudo apt install -y build-essential gettext pkg-config libglib2.0-dev python3-dev libpixman-1-dev binutils libgtk-3-dev texinfo make gcc-riscv64-linux-gnu libncurses5-dev ninja-build tmux axel git Ubuntu 的软件源中没有支持模拟RISC-V的QEMU和支持调试RISC-V的GDB，需要我们自行编译源码安装。下载 QEMU 6.0.0 和 GDB 10.2 的源码包。选择这两个版本也没有什么原因，就是系统编写时的最新稳定版罢了。 下载完成后解压即可： tar xJf qemu-6.0.0.tar.xz tar xJf gdb-10.2.tar.xz 进入解压后的 QEMU 源码目录，使用如下配置编译安装，这里配置了 QEMU 的模拟目标架构是32位和64位的 RISC-V，同时编译图形界面（使用 GTK 图形界面库，一个 Linux 下主流的图形界面库）。 ./configure --target-list=riscv32-softmmu,riscv64-softmmu --enable-gtk make -j$(nproc) sudo make install 进入解压后的 GDB 源码目录，使用如下配置编译安装，配置了 GDB 的目标调试架构是 RISC-V 64位，同时编译 TUI 界面（文本用户界面）模式，添加 Python3 调试脚本支持。 ./configure --target=riscv64-unknown-elf --enable-tui=yes -with-python=python3 make -j$(nproc) sudo make install 这样安装就大致完成了，可以输入以下命令检测编译安装的软件的版本信息： riscv64-unknown-elf-gdb -v qemu-system-riscv64 --version 应该能看到这样的信息： GNU gdb (GDB) 10.2 Copyright (C) 2021 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. QEMU emulator version 6.0.0 Copyright (c) 2003-2021 Fabrice Bellard and the QEMU Project developers 执行 qemu-system-riscv64 -machine virt -nographic，可以看到如下输出： OpenSBI v0.9 ____ _____ ____ _____ / __ \\ / ____| _ \\_ _| | | | |_ __ ___ _ __ | (___ | |_) || | | | | | '_ \\ / _ \\ '_ \\ \\___ \\| _ 表示QEMU可正常使用。 Qemu 可以使用 Ctrl + A 再按下 x 退出（注意要松开 Ctrl 和 A 再单独按x，这是一套组合按键，并不是只按 Ctrl + A 就可以的）。 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"helloworld/":{"url":"helloworld/","title":"你好，世界","keywords":"","body":"你好，世界 在这一章，我们会构建并启动到一个能输出一些检测信息和字符串的最简单的系统内核，同时也会介绍一些在这过程中需要用到的编译、链接和各种配置的知识和 RISC-V 的启动过程相关知识。 本章对应代码：lab1 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"helloworld/main.html":{"url":"helloworld/main.html","title":"“主”函数的编写","keywords":"","body":"“主”函数的编写 关于“主”函数的一些说明 通常我们的 C 语言程序都会有一个主函数（main 函数）作为程序的入口，在这里我们也先写一个 main 函数作为我们的内核的“主”函数，之所以在“主”函数上加引号，是因为实际上这个函数并不是整个系统真正的入口，而 main 的名字也是可以任意取的，这一细节后续还会再提到，在这里还是遵循我们的习惯，将它取名为 main。 相关函数的介绍 在编写操作系统时是有很多地方与编写普通程序有很大的不同的，首先就是写代码的时候无法使用一些常用的头文件，如 stdio.h, stdlib.h 等，因为这些头文件是依赖于系统的实现的，换句话说，这些头文件的功能并不是 C 语言或编译器天生就具备的，而是由操作系统提供了底层支持，由操作系统完成了内部的一些函数和定义。 既然不能使用这些头文件，我们就无法使用 printf, scanf, puts, gets, putchar, getchar 之类的函数。好在，sbi 为我们提供了一些字符输入输出的环境调用功能，但是需要我们使用汇编语言来调用，因此我们会对这些功能做 C 语言的函数封装，这样我们就能借助我们自己封装的 C 语言函数使用它们了。 在 main 函数中，我们使用了这几个封装： sbi_probe_extension 探测 SBI 扩展的可用情况 sbi_console_putchar 打印字符 sbi_get_impl_id 获取当前的 SBI（Supervisor 二进制接口）实现 ID 同样我们也自己定义了一个符合 sbi 标准的结构体类型struct sbiret，用于表示一些 sbi 环境调用的返回值。在 main 函数中，主要是 sbi_probe_extension 函数使用了这个结构体，返回的值中若成员 value 的值不为0，则表示功能扩展可用，这些标准都会在后续介绍到，此处暂且不提。 另外我们又对 sbi_console_putchar 做了进一步封装，封装后函数名为 kputs，可以直接输出字符串，并在最后输出换行，封装代码如下： static void kputs(const char *msg) { for ( ; *msg != '\\0'; ++msg ) { sbi_console_putchar(*msg); } sbi_console_putchar('\\n'); } “主”函数代码与功能介绍 在这里给出 main 函数的代码： int main() { struct sbiret ret; ret = sbi_probe_extension(TIMER_EXTENTION); if (ret.value != 0) kputs(\"TIMER_EXTENTION: available\"); else kputs(\"TIMER_EXTENTION: unavailable\"); ret = sbi_probe_extension(SHUT_DOWN_EXTENTION); if (ret.value != 0) kputs(\"SHUT_DOWN_EXTENTION: available\"); else kputs(\"SHUT_DOWN_EXTENTION: unavailable\"); ret = sbi_probe_extension(HART_STATE_EXTENTION); if (ret.value != 0) kputs(\"HART_STATE_EXTENTION: available\"); else kputs(\"HART_STATE_EXTENTION: unavailable\"); ret = sbi_get_impl_id(); switch (ret.value) { case BERKELY_BOOT_LOADER: kputs(\"Implemention ID: Berkely boot loader\"); break; case OPENSBI: kputs(\"Implemention ID: OpenSBI\"); break; case XVISOR: kputs(\"Implemention ID: XVISOR\"); break; case KVM: kputs(\"Implemention ID: KVM\"); break; case RUSTSBI: kputs(\"Implemention ID: RustSBI\"); break; case DIOSIX: kputs(\"Implemention ID: DIOSIX\"); break; default: kputs(\"Implemention ID: Unkonwn\"); } kputs(\"Hello LZU OS\"); while (1) ; /* infinite loop */ return 0; } 根据前面的说明，我们很容易读通这个程序，它所做的不过就是检测TIMER_EXTENTION（时钟）、SHUT_DOWN_EXTENTION（关机）、HART_STATE_EXTENTION（硬件级线程，这一拓展我们实际并不会使用，只是单纯的检测一下）这几个 sbi 扩展是否可用 (available) ，检测当前 sbi 的实现，最后输出\"Hello LZU OS\"，随后陷入死循环。 小知识：HART 硬件级线程 hart 是硬件线程(hardware thread)的缩略形式。 我们用该术语将它们与大多数程序员熟悉的软件线程区分开来。软件线程在 harts 上进行分时复用。 大多数处理器核都只有一个hart。—— 摘自《RISC-V 手册》 如果一个部件包含了一个独立的取指令单元，则该部件被称为核心(core)。一个RiscV兼容的核心能够通过多线程技术(或者说超线程技术)支持多个RiscV兼容硬件线程(harts)，harts这儿就是指硬件线程， hardware thread的意思。所谓超线程技术，就是在一个硬件核中，实现多份硬件线程，每个硬件线程都有自己独立的寄存器组等上下文资源，但大多数的运算资源都被所有线程复用，因此面积效率很高。超线程最早出现是在Intel的处理器中。—— 摘自 Risc-V简要概括 ( archive.is互联网存档 ) 简而言之，硬件级线程和现在常见的 x86 处理器上的“m 核 n 线程”中的“n 线程”对应，若处理器设计时没有做超线程，那么一个核心就是一个硬件及线程，若有做超线程，那么某些核心可以有多个线程。 为什么 main 函数到最后是陷入死循环而不是退出呢？我们在讲完完整的启动流程后再来回顾这个问题。 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"helloworld/packaging.html":{"url":"helloworld/packaging.html","title":"ecall 指令的封装","keywords":"","body":"封装 ecall 指令 [ ] 解释 ecall [ ] 为什么要封装 [ ] 解释内联汇编 [ ] 解释如何封装 [ ] sbi-doc 标准 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"helloworld/boot.html":{"url":"helloworld/boot.html","title":"操作系统的启动","keywords":"","body":"操作系统的启动 [ ] 开机加载SBI（内存地址） [ ] SBI加载内核（内存地址） [ ] 内核如何加载 [ ] entry.s的解释 [ ] 如何进入main函数的 [ ] 为什么说main函数并不是整个系统真正的入口，系统真正的入口在哪里（entry.s，0x80200000） 为什么 main 函数到最后是陷入死循环而不是退出呢？ 可以分两种情况来思考一下这个问题： 如果这是一个最顶层的 C 语言函数（当前代码就是这种情况，这个函数不是被其他的 C 语言函数调用的），结束时没有陷入死循环，那么函数结束自然就会返回（函数体的右大括号就代表了函数返回，无论是否有 return 语句） 在常规操作系统中，一个进程最顶层的函数结束了，会返回到创建这个进程的父进程，如果是在命令行中执行的进程，那么这个父进程就是 shell 程序。 在我们的操作系统中，是汇编程序 entry.s 调用了 main 函数，反汇编 entry.s 编译出来的目标文件 entry.o 可以看出它将调用 main 函数的那行指令的内存地址压入栈中，便于结束调用时返回，那么被调用的函数结束时返回到的指令执行位置就是调用它的那行语句，那么它就会被再次调用，也就是会出现不断循环 main 函数的情况（可以在 main 函数里删去最后的循环就能看到这个现象）。 如果是汇编语言结束，没有陷入死循环 汇编语言其实没有结束的概念，CPU 只会不断地取指、执行，若没有跳转语句，CPU 会不断往下执行，即使内存后面存储的已经不是我们所希望计算机执行的指令了。在这之后可能是无意义的内存内容，或者是我们在内存中存的数据，或者是我们原本存在后面的等待被调用的函数，但 CPU 不会理解它们到底是什么，它只会不断地向后取值，并把它们当作正常指令来执行，因此就会出现各种预期之外的执行结果。 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"helloworld/make.html":{"url":"helloworld/make.html","title":"拼搭我们的系统","keywords":"","body":"拼搭我们的系统 [ ] 编写完成后我们需要将我们的系统编译并拼接起来（介绍词） 编译链接我们的代码 [ ] 我们的系统是如何被编译链接的（参考makefile的注释） [ ] 可以加一点make的知识 [ ] 参考资料：https://www.ruanyifeng.com/blog/2015/02/make.html [ ] 参考资料：https://seisman.github.io/how-to-write-makefile/implicit_rules.html [ ] 链接脚本(linker.ld)是什么意思 执行与调试的启动 [ ] 如何启动系统，在makefile里是怎么体现的 [ ] 如何进入调试，在makefile里是怎么体现的 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"helloworld/linker_script.html":{"url":"helloworld/linker_script.html","title":"附录：链接脚本 Linker Script","keywords":"","body":"附录：链接脚本 Linker Script 本文根据文档 Linker Script 翻译而成。 链接脚本（Linker Script）是用于控制链接器 ld 执行的命令脚本，主要用于描述多个输入的目标文件如何被映射到一个输出的目标文件中，并控制输出文件的内存布局。如果没有指定，则会使用自带的链接脚本来生成可执行文件。由于我们需要手动指定我们自己的操作系统内存布局，因此需要编写一个链接脚本。 在使用时，需要给 ld 加上 -T 参数以指定链接脚本。 基本概念 链接器将输入文件合并为单个输出文件。 目标文件格式(object file format)：每个输入文件和输出文件的一种特殊的数据格式。 目标文件(object file)：每个文件都称为目标文件。其中输出文件通常也被称为可执行文件。 每个目标文件都有一个列表记录了目标文件的各个节(sections)。 输入节(input section)：输入文件中的一个节。 输出节(output section)：输出文件中的一个节。 目标文件中的每个节都有一个名称和大小。大多数节还有一个相关联的数据块，称为节内容(section contents)。节可以标记为可加载的(loadable)，这意味着在运行输出文件时，节内容应该加载到内存中。没有内容的节可能是可分配的(allocatable)，这意味着应在内存中预留一个区域，但是无需填写内容(在某些情况下须填零)。既不可加载也不可分配的节通常包含某种调试信息。 每个可加载或可分配的输出节有两个地址。第一个是 VMA，即虚拟内存地址(virtual memory address)。这是该节在运行输出文件时将拥有的地址。第二个是 LMA，即加载内存地址(load memory address)。这是将要加载节的地址。在大多数情况下，两个地址是相同的。 通过使用带有-h选项的objdump程序，可以查看目标文件中的节。 每个目标文件都有一个符号(symbol)列表，称为符号表(symbol table)。符号可以是已定义的，也可以是未定义的。每个符号都有一个名称，每个已定义的符号都有一个地址。如果将C或C++程序编译成目标文件，则每个已定义的函数和全局变量或静态变量对应一个已定义的符号。输入文件中引用的每个未定义的函数或全局变量都将成为未定义的符号。 可以通过使用 nm 程序或使用带有 -t 选项的 objdump 程序来查看目标文件中的符号。 链接脚本格式 它是一个含有一系列命令的文本文件，每个命令是一个可有参数的关键字，或对一个符号赋值。命令可用分号分隔，空格将被忽略。 通常可以直接输入文件名或格式名等字符串。如果文件名包含分隔符（如逗号），则可以将文件名放在双引号中。文件名中不得有双引号。 链接脚本的注释由/*和*/包围。 简单示例 最简单的链接脚本只有一个命令：SECTIONS。您可以使用SECTIONS命令来描述输出文件的内存布局。 SECTIONS命令是一个强大的命令。假设程序只包含代码、已初始化的数据和未初始化的数据。这些分别在 .text, .data 与 .bss 节中，并进一步假设输入文件中仅有这些节。 对于本例，假设代码应该加载到地址0x10000，已初始化的数据和未初始化的数据应该从地址0x8000000开始并相连。相应的链接脚本如下： SECTIONS { . = 0x10000; .text : { *(.text) } . = 0x8000000; .data : { *(.data) } .bss : { *(.bss) } } SECTIONS命令以关键字SECTIONS开始，然后是一系列符号赋值和用大括号括起来的输出节描述。 上例中SECTIONS命令的第一行用于设置特殊符号.的值，这是位置计数器。如果不以其他方式指定输出节的地址（其他方式将在后面介绍），则将根据位置计数器的当前值设置地址。然后，位置计数器按输出节的大小递增。若不额外设置，在SECTIONS命令的开头，位置计数器的值为0。 第二行定义了一个输出节.text，其中冒号是必需的语法，目前可忽略。在输出节名称后的大括号内，列出了应放入此输出节的输入节的名称。* 是一个与任何文件名匹配的通配符。*(.text)表示所有输入文件中的.text输入节。 由于定义输出节.text时，位置计数器为0x10000，链接器将设置输出文件中的.text节的地址为0x10000。 剩余的行定义输出文件中的.data和.bss节。链接器将在0x8000000地址处放置.data输出节。链接器放置.data输出节后，位置计数器的值将为 $ 0x8000000+.data输出节的大小 $ ，因此链接器将在.data后立即放置.bss输出节。 链接器将确保每个输出节都具有所需的对齐方式，必要时增加位置计数器。在本例中，.text和.data节的指定地址满足任何对齐约束，但链接器可能必须在.data和.bss节之间创建一个小的间隙以满足部分对齐要求。 简单命令 入口点 在程序中执行的第一条指令称为入口点(Entry Point)。您可以使用ENTRY命令设置入口点，参数是一个符号名称： ENTRY(symbol) 有几种方法可以设置入口点。链接器将通过按顺序（即优先级从高到低）尝试以下每个方法来设置入口点直至成功： 命令行通过 -e 传参; 链接脚本中的ENTRY(symbol)命令; 平台相关的符号的值（若有）。对于多数平台来说是 start，但基于PE和BeOS的系统会检查可能的入口符号列表，匹配找到的第一个。 代码节的第一个字节的地址，如果存在并且正在创建一个可执行文件。代码节通常是.text，也可以是其他名称; 地址 0。 文件命令 INCLUDE filename 在该命令处调用另一个链接脚本。 将在当前目录以及使用-L选项指定的目录中搜索该文件。嵌套调用最多10级。 INCLUDE指令可放在顶层、MEMORY或SECTIONS命令中，或放在输出节的描述中。 INPUT(file, file, …) INPUT(file file …) INPUT 命令表示在链接中包含这些文件，就像在命令行参数中被指定一样。 例如总希望在链接时包含 subr.o，但是无法将其放在每个链接命令的参数中，此时就可以在链接脚本中加入INPUT (subr.o)。 实际上，甚至可以在链接脚本中列出所有输入文件，然后使用-t选项指定链接脚本而不在参数中引用任何输入文件。 如果配置了 sysroot prefix 目录，并且文件名以 / 字符开头，并且正在处理的脚本位于 sysroot prefix 目录，则将在 sysroot prefix 目录中查找文件。也可以让文件名路径以=开头，或者使用$SYSROOT作为文件名路径的前缀来强制使用 sysroot prefix。另请参阅命令行选项中-L参数的描述。 如果未使用 sysroot prefix，则链接器将尝试在包含链接脚本的目录中打开文件。若未找到，将搜索当前目录。如果仍未找到，链接器将在库的搜索路径中查找。 如果使用 INPUT (-lfile)，ld 会将名称转换为 libfile.a，与命令行参数-l一样。 当您在隐式链接脚本中使用INPUT命令时，文件将在链接脚本被引用时才被加入。这可能会影响库的搜索。 GROUP(file, file, …) GROUP(file file …) GROUP 命令与 INPUT 类似，只是被指定的文件都应该是库文件，并且要反复搜索这些文件，直到没有创建新的未定义的引用。请参见命令行选项中 -( 的说明。 AS_NEEDED(file, file, …) AS_NEEDED(file file …) 这个结构只能出现在 INPUT 或 GROUP 命令以及其他文件名中。列出的文件将像直接出现在 INPUT 或 GROUP 命令中一样进行处理，但 ELF 共享库除外，它们只有在实际需要时才添加这些文件。这个结构实质上为其中列出的所有文件启用了 -as-needed 选项，为了恢复以前编译环境，之后需设置 --no-as-needed。 OUTPUT(filename) OUTPUT 命令设置输出文件的文件名。在链接脚本中使用OUTPUT(filename)与在命令行中使用-o filename完全相同（请参见命令行选项），且命令行选项优先。 可以使用OUTPUT命令设置默认输出文件名，而不是通常的默认名称a.out。 SEARCH_DIR(path) SEARCH_DIR命令将path添加到ld查找库的路径列表中。使用SEARCH_DIR(path)与在命令行上使用-L path完全相同（请参见命令行选项）。如果两者都使用，那么链接器将搜索两者的路径。首先搜索使用命令行选项指定的路径。 STARTUP(filename) STARTUP 命令与 INPUT 命令类似，只是 filename 将成为第一个要链接的输入文件，就好像它是在命令行中首先指定的一样。在使用那些入口点始终是第一个文件的起始处的系统时将会很有用。 格式命令 OUTPUT_FORMAT(bfdname) OUTPUT_FORMAT(default, big, little) OUTPUT_FORMAT 命令指定用于输出文件的 BFD 格式（请参见 BFD）。使用 OUTPUT_FORMAT(bfdname) 与在命令行上使用 --oformat bfdname 完全相同（请参见命令行选项），且命令行选项优先。 根据-EB和-EL命令行选项，可以使用带有三个参数的 OUTPUT_FORMAT 来使用不同的格式。这允许链接脚本根据所需的大小端设置输出格式。 如果既不使用-EB也不使用-EL，则输出格式将是第一个参数（default）。如果使用-EB，输出格式将是第二个参数(big)。如果使用-EL，则输出格式将是第三个参数(little)。 例如，MIPS ELF 目标平台的默认链接脚本使用以下命令： OUTPUT_FORMAT(elf32-bigmips, elf32-bigmips, elf32-littlemips) 这表示输出文件的默认格式为elf32-bigmips，但如果用户使用-EL命令行选项，则输出文件将以 elf32-littlemips 格式创建。 TARGET(bfdname) TARGET 命令指定读取输入文件时使用的 BFD 格式。它影响后续的 INPUT 和 GROUP 命令。这个命令类似于在命令行上使用-b bfdname（请参见命令行选项）。如果使用 TARGET 命令而不使用 OUTPUT_FORMAT，那么最后一个 TARGET 命令也用于设置输出文件的格式。参见 BFD。 REGION_ALIAS 为内存区域指定别名。 别名可以添加到使用 MEMORY 命令创建的现有内存区域中。每个名称最多对应一个内存区域。 REGION_ALIAS(alias, region) REGION_ALIAS 函数为内存区域 region 创建别名 alias。可将输出节灵活地映射到内存区域。 一个简单的例子： 假设我们有一个嵌入式系统的应用程序，它带有各种内存存储设备。它们都有一个通用的易失性内存 RAM，可以执行代码或存储数据。有些可能有一个只读的，非易失的 ROM，允许代码执行和只读数据访问。最后一种是只读的、非挥发性记忆体的 ROM2，具有只读数据访问，但无代码执行能力。我们有四个输出节: .text 程序代码; .rodata 只读数据; .data 可写的已初始化的数据; .bss 可写的填零的数据. 我们的目标是提供一个链接器命令文件，其中包含一个定义输出节的系统无关部分，以及一个将输出节映射到系统上可用内存区域的系统相关部分。我们的嵌入式系统有三种不同的内存设置A、B和C： Section Variant A Variant B Variant C .text RAM ROM ROM .rodata RAM ROM ROM2 .data RAM RAM/ROM RAM/ROM2 .bss RAM RAM RAM 符号 RAM/ROM 或 RAM/ROM2 表示该节分别加载到区域 ROM 或 ROM2 中。请注意，.data 的加载地址在三个不同的方案中都在 .rodata 的结尾处开始。 下面是处理输出节的基本链接脚本。它包括依赖于系统的描述内存布局的 linkcmds.memory 文件： INCLUDE linkcmds.memory SECTIONS { .text : { *(.text) } > REGION_TEXT .rodata : { *(.rodata) rodata_end = .; } > REGION_RODATA .data : AT (rodata_end) { data_start = .; *(.data) } > REGION_DATA data_size = SIZEOF(.data); data_load_start = LOADADDR(.data); .bss : { *(.bss) } > REGION_BSS } 现在我们需要三个不同的 linkcmds.memory 文件来定义内存区域和别名名称。对于这三种方案，linkcmds.memory 的内容分别是： A：全都放入 RAM MEMORY { RAM : ORIGIN = 0, LENGTH = 4M } REGION_ALIAS(\"REGION_TEXT\", RAM); REGION_ALIAS(\"REGION_RODATA\", RAM); REGION_ALIAS(\"REGION_DATA\", RAM); REGION_ALIAS(\"REGION_BSS\", RAM); B：代码和只读数据放入 ROM，可写数据放入 RAM。已初始化数据的映像被加载到 ROM 中，并在系统启动期间被复制到 RAM 中。 MEMORY { ROM : ORIGIN = 0, LENGTH = 3M RAM : ORIGIN = 0x10000000, LENGTH = 1M } REGION_ALIAS(\"REGION_TEXT\", ROM); REGION_ALIAS(\"REGION_RODATA\", ROM); REGION_ALIAS(\"REGION_DATA\", RAM); REGION_ALIAS(\"REGION_BSS\", RAM); C：代码放入 ROM，只读数据放入 ROM2，可写数据放入 RAM。已初始化数据的映像被加载到 ROM2 中，并在系统启动期间被复制到 RAM 中。 MEMORY { ROM : ORIGIN = 0, LENGTH = 2M ROM2 : ORIGIN = 0x10000000, LENGTH = 1M RAM : ORIGIN = 0x20000000, LENGTH = 1M } REGION_ALIAS(\"REGION_TEXT\", ROM); REGION_ALIAS(\"REGION_RODATA\", ROM2); REGION_ALIAS(\"REGION_DATA\", RAM); REGION_ALIAS(\"REGION_BSS\", RAM); 如果需要，可以编写通用的系统初始化例程以将来自 ROM 或 ROM2 的 .data 节复制到RAM中： #include extern char data_start []; extern char data_size []; extern char data_load_start []; void copy_data(void) { if (data_start != data_load_start) { memcpy(data_start, data_load_start, (size_t) data_size); } } 其他命令 其他命令有： ASSERT(exp, message) EXTERN(symbol symbol …) FORCE_COMMON_ALLOCATION INHIBIT_COMMON_ALLOCATION FORCE_GROUP_ALLOCATION INSERT [ AFTER | BEFORE ] output_section NOCROSSREFS(section section …) NOCROSSREFS_TO(tosection fromsection …) OUTPUT_ARCH(bfdarch) LD_FEATURE(string) 其中我们项目中只用到了OUTPUT_ARCH(bfdarch)，因此不对其余命令做介绍，有兴趣可自行阅读文档。 OUTPUT_ARCH(bfdarch) 用于指定特定的输出体系结构。参数是 BFD 库使用的名称之一（请参见 BFD）。使用 objdump 程序加 -f 参数可以看到目标文件的体系结构。 为符号赋值 可以在链接脚本中为符号赋值。这将定义符号并将其放置到具有全局作用域的符号表中。 简单赋值 可以使用C语言中的任何给符号赋值的操作符，末位必须有分号： symbol = expression ; symbol += expression ; symbol -= expression ; symbol *= expression ; symbol /= expression ; symbol >= expression ; symbol &= expression ; symbol |= expression ; 特殊的符号名称 . 表示位置计数器。您只能在 SECTIONS 命令中使用此符号。见位置计数器。 表达式在下面定义（请参阅表达式）。 符号赋值可以作为命令本身编写，或者作为 SECTIONS 命令中的语句编写，或者作为 SECTIONS 命令中的输出节描述的一部分。 下面的例子展示了三个可以使用符号赋值的不同地方: floating_point = 0; SECTIONS { .text : { *(.text) _etext = .; } _bdata = (. + 3) & ~ 3; .data : { *(.data) } } 在此示例中，符号floating_point将被定义为 0。符号_etext将被定义为最后一个.text输入节结束之后的地址。符号_bdata将被定义为.text输出节结束之后的地址向上对齐至4字节边界。 除此之外，还有 HIDDEN、PROVIDE、PROVIDE_HIDDEN 命令可供选用，项目中暂时用不到，可以参考文档自行理解。 在程序源代码中引用链接脚本符号 从程序源代码中访问链接脚本定义的变量并不直观。尤其是链接脚本符号并不等同于高级语言中的变量声明，而是一个没有值的符号。 请注意当编译器将源代码中的名称存储在符号表中时，它们通常会将变量转换为不同的名称。例如，Fortran 编译器通常会添加下划线，而 C++ 会执行广泛的重整(name mangling)。因此，在源代码中使用的变量的名称和与链接脚本中定义相同的变量的名称可能存在差异。例如，在 C 中，链接脚本变量可能被引用为： extern int foo; 但在链接脚本中它可能被定义为: _foo = 1000; 假设没有发生名称转换，当用高级语言（如C）声明一个符号时，编译器首先会在程序内存中预留空间来保存符号的值，然后在符号表中创建条目来保存符号的地址。例如： int foo = 1000; 编译器会在符号表中创建一个名为foo的条目，保存了存储数字 1000 的int大小的内存块的地址。 当程序引用符号时，编译器生成的代码会首先访问符号表以查找符号的地址，然后读取该地址所存的值。所以 foo = 1; 查找符号表中的符号foo，获取关联的地址，然后将值 1 写入该地址。 而 int * a = & foo; 查找符号表中的符号foo，获取其地址，然后将此地址复制到与变量a关联的内存块中（即赋值给a）。 相比之下，链接脚本符号声明命令会在符号表中创建一个条目，但不为它们分配任何内存。因此，它们是一个没有值的地址。例如，链接脚本定义 foo = 1000; 将会在符号表中创建一个名为foo的条目，该条目保存内存位置1000的地址，但在地址1000处未存储任何特殊内容。这意味着无法访问链接脚本定义的符号的值（它没有值），所能做的就是访问链接脚本定义的符号的地址。 因此，当在源代码中使用链接脚本定义的符号时，应该始终获取符号的地址，而不要使用其值。例如要将.ROM节的内容复制到.FLASH，且链接脚本中包含这些声明： start_of_ROM = .ROM; end_of_ROM = .ROM + sizeof (.ROM); start_of_FLASH = .FLASH; 则复制内容的C语言代码应这样写，注意其中的&。： extern char start_of_ROM, end_of_ROM, start_of_FLASH; memcpy (& start_of_FLASH, & start_of_ROM, & end_of_ROM - & start_of_ROM); 或者使用数组表示法： extern char start_of_ROM[], end_of_ROM[], start_of_FLASH[]; memcpy (start_of_FLASH, start_of_ROM, end_of_ROM - start_of_ROM); SECTIONS 命令 SECTIONS 命令告诉链接器如何将输入节映射到输出节，以及如何将输出节放入内存。 SECTIONS 命令的格式为： SECTIONS { sections-command sections-command … } 每个 sections-command 可以是以下命令之一： ENTRY 命令（参见输入命令） 符号赋值（请参见赋值） 输出节描述 覆盖描述 为了方便在这些命令中使用位置计数器，允许在 SECTIONS 命令中使用 ENTRY 命令和符号赋值。这还可以使链接脚本更容易理解，因为在输出文件布局中有意义的地方可以使用这些命令。 输出节描述和覆盖描述如下： 如果在链接脚本中不使用 SECTIONS 命令，链接器将按照在输入文件中首先遇到的顺序，将每个输入节放入一个同名的输出节中。例如，如果第一个文件中存在所有输入节，则输出文件中节的顺序将与第一个输入文件中的顺序匹配。第一个节将在地址 0 处。 输出节描述 一个完整的输出节描述如下： section [address] [(type)] : [AT(lma)] [ALIGN(section_align) | ALIGN_WITH_INPUT] [SUBALIGN(subsection_align)] [constraint] { output-section-command output-section-command … } [>region] [AT>lma_region] [:phdr :phdr …] [=fillexp] [,] 大多数节属性并不会被广泛使用。 section 是节的名字，必须满足输出的目标文件的格式限制。在仅支持有限数量节的格式中，名称必须是该格式支持的名称之一（例如，a.out 格式的输出文件只允许使用.text、.data或.bss）。 如果输出目标文件的格式支持任意数量的节，但只有数字（就像 Oasys 的情况一样），则名称应作为带引号的数字字符串提供。节名可以由任何字符序列组成，但包含任何不寻常字符（如逗号）的名称必须加引号。/DISCARD/ 是个特殊的名字，参见输出节丢弃。 section 两边的空白符是必须的，以保证节的名字不会混淆。冒号和花括号也是必须的。当使用了 fillexp 且下一个 sections-command 看起来像表达式的延续时需要结尾的逗号，换行和其他空白符是可选的。 每个 output-section-command 可以是以下命令之一： 符号赋值（请参阅赋值） 输入节描述（参见输入节） 直接包含的数据值（请参阅输出节数据） 特殊输出节关键字（请参阅输出节关键词） 输出节地址 上一部分中，address 是输出节的VMA（虚拟内存地址）的表达式。此地址是可选的，但如果提供了此地址，则输出地址将完全照此设置。 如果未指定输出地址，则将根据下面的方法中尝试。此时地址会被调整以符合对齐要求。输出节的对齐要求是所有输入节中含有的对齐要求中最严格的一个。 如果为该区域设置了输出内存区域（上面的 region 字段），那么它将被添加到该区域，其地址将是该区域中的下一个空闲地址。 如果使用 MEMORY 命令创建一个内存区域列表，那么将选择具有与该节兼容的属性的第一个区域来包含它。该节的输出地址将是该区域的下一个空闲地址;。 如果没有指定内存区域，或者没有匹配节，则输出地址将基于当前位置计数器的值。 例如 .text . : { *(.text) } 和 .text : { *(.text) } 有些许不同，前一个将设置输出节的地址为当前位置计数器的值，而后一个将设置输出节的地址为当前位置计数器的值经过对齐后的值。 address 也可以是任意表达式。例如，如果想在 0x10 字节边界上对齐节，使节地址的最低四位为零，可以使用 .text ALIGN(0x10) : { *(.text) }，其中 ALIGN 返回当前位置计数器向上对齐至指定值。 指定节的 address 将更改位置计数器的值，前提是这一节是非空的。（空节会被忽略）。 输入节 输入节描述是最基本的链接脚本操作。输出节告诉链接器如何在内存中放置程序，而输入节描述告诉链接器如何将输入文件映射到内存布局中。 输入节基础 输入节描述由文件名（可选）和括号中的节名列表组成。 文件名和节名可以是通配符模式（请参阅输入节通配符） 最常见的输入节描述是在输出节中包含具有特定名称的所有输入节。例如，包含所有输入文件的.text节：*(.text)。 这里 * 是一个匹配任何文件名的通配符。要从匹配文件名通配符中排除一些文件，则可以使用 EXCLUDE_FILE 排除。例如：EXCLUDE_FILE (*crtend.o *otherfile.o) *(.ctors) 将会包含除了 crtend.o 和 otherfile.o 之外的所有输入文件中的 .ctors 节。也可以放入节列表，如 *(EXCLUDE_FILE (*crtend.o *otherfile.o) .ctors) ，结果是相同的。如果有节列表有多个节，EXCLUDE_FILE 的两种语法就很有用了。 有两种方法可以包含多个输入节： 使用空格分隔节名列表，例如 *(.text .rdata)； 使用括号分隔节名列表，例如 *(.text) *(.rdata)。 这两者之间的区别在于 ‘.text’ 和 ‘.rdata’ 输入节放置在输出节中的顺序。前者将混在一起，出现的顺序与它们在链接器输入中出现的顺序相同。后者会先放所有的 .text 节，然后放所有的 .rdata 节。 当将 EXCLUDE_FILE 与多个节一起使用时，如果使用在节列表中，则排除仅适用于紧接着的节，例如 *(EXCLUDE_FILE (*somefile.o) .text .rdata) 会排除 somefile.o 中的 .text 节，但是会包含所有文件的 .rdata 节。如想同时排除 somefile.o 中的 .rdata 节，则可以使用 *(EXCLUDE_FILE (*somefile.o) .text EXCLUDE_FILE (*somefile.o) .rdata)，或者把 EXCLUDE_FILE 放在节列表外，例如 EXCLUDE_FILE (*somefile.o) *(.text .rdata)。 如果某些文件特定位置的特殊数据需要包含在内存中，则可以指定文件名以包含来自特定文件的节。例如：data.o(.data) 将会包含 data.o 中的 .data 节。 使用 INPUT_SECTION_FLAGS 可以通过输入节的节标志(section flags)来选择节，比如我们可以使用 ELF 节的节头标志(Section header flags)： SECTIONS { .text : { INPUT_SECTION_FLAGS (SHF_MERGE & SHF_STRINGS) *(.text) } .text2 : { INPUT_SECTION_FLAGS (!SHF_WRITE) *(.text) } } 在此示例中，输出部分 .text 将由匹配名称 *(.text) 且节头标志设置了 SHF_MERGE 与 SHF_STRINGS 标志的所有输入节组成。输出部分 .text2 将由匹配名称 *(.text) 且节头标志未设置 SHF_WRITE 标志的所有输入节组成。 还可以通过编写与库文件匹配的模式来指定文件，项目中未使用，如有需要请参考Input Section Basics 如果没有指定节列表而直接使用文件名，则输入文件中的所有节都将包含在输出节中。这不常见，但有时可能有用。例如： data.o 当使用的文件名不是archive:file说明符且不包含任何通配符时，链接器将首先查看是否还在链接器命令行或输入命令中指定了文件名。如果没有，链接器将尝试将该文件作为输入文件打开，就像它出现在命令行上一样。请注意，这与 INPUT 命令不同，因为链接器不会在库搜索路径中搜索文件。 输入节通配符 在输入节描述中，文件名和节名都可以用通配符。在许多示例中看到的 * 文件名是简单的通配符模式。 * 匹配任何文件名。 ? 匹配任何单字符。 [chars] 匹配任何字符集合中的一个元素，其中 - 符号可以用来表示一个范围，如 [a-z] 匹配所有的小写字母。 \\ 可以用来转义字符，如 \\* 匹配 *。 文件名通配符只匹配在命令行或 INPUT 命令上明确指定的文件。链接器不搜索目录以扩展通配符。 如果文件名与多个通配符模式匹配成功，或者如果文件名被显式地指定且同时由通配符模式匹配成功，则链接器将使用链接脚本中的第一个匹配项。例如，以下命令可能出错，因为 data.o 规则不会被使用： .data : { *(.data) } .data1 : { data.o(.data) } 通常，链接器将以在链接期间发现的顺序排列通配符匹配的文件和节。 SORT_BY_NAME（或SORT)关键词可以更改这一顺序，该关键字放置在括号中的通配符模式前（例如 SORT_BY_NAME(.text*)）。使用 SORT_BY_NAME 关键字时，链接器会按文件或节名升序排序放入输出文件。 同样的，SORT_BY_ALIGNMENT 会将节按对齐方式降序排列，大的对齐被放在小的对齐前面可以减少所需的填充量。 SORT_BY_INIT_PRIORITY 按照编码在节名中的 GCC init_priority 属性升序排列节，在 .init_array.NNNNN 和 .fini_array.NNNNN 中，NNNNN 就是 init_priority。在 .ctors.NNNNN 和 .dtors.NNNNN 中，NNNNN 是 65535 减去 init_priority. 当链接器脚本中有嵌套节排序命令时，最多可以嵌套一层： SORT_BY_NAME (SORT_BY_ALIGNMENT (wildcard section pattern)) 先按名，同名时再按对齐方式排序。 SORT_BY_ALIGNMENT (SORT_BY_NAME (wildcard section pattern)) 先按对齐方式，同对齐时再按名排序。 SORT_BY_NAME (SORT_BY_NAME (wildcard section pattern)) 和单层 SORT_BY_NAME 相同。 SORT_BY_ALIGNMENT (SORT_BY_ALIGNMENT (wildcard section pattern)) 和单层 SORT_BY_ALIGNMENT 相同。 其他嵌套方式均无效。 当命令行排序选项和脚本排序选项同时使用时，脚本排序选项优先。 如果链接脚本没有排序嵌套，命令行选项也可能导致排序的嵌套： SORT_BY_NAME(wildcard section pattern) 与 --sort-sections alignment 共用等价于 SORT_BY_NAME (SORT_BY_ALIGNMENT (wildcard section pattern)) SORT_BY_ALIGNMENT(wildcard section pattern) 与 --sort-section name 共用等价于 SORT_BY_ALIGNMENT (SORT_BY_NAME (wildcard section pattern)) 如果链接脚本中的排序命令已经发生嵌套，则将忽略命令行选项。 使用 SORT_NONE 可以忽略命令行节排序选项。 如果对输入节在输出文件中的布局感到困惑，请使用-M链接器选项生成 map 文件。map 文件精确地显示了如何将输入节映射到输出节。 下面这个例子中，链接器会将所有输入的 .text 节放入输出 .text 节，并且将所有输入的 .bss 节放入输出 .bss 节。所有大写字母开头的输入文件中的 .data 节都会被放入输出 .DATA 节。对于其他文件，链接器会将它们的 .data 节放入输出 .data 节。 SECTIONS { .text : { *(.text) } .DATA : { [A-Z]*(.data) } .data : { *(.data) } .bss : { *(.bss) } } 输入节通用符号 请参考Input Section for Common Symbols 输入节与垃圾回收 当使用链接时垃圾回收功能 --gc-sections 时，通常应标记不应删除的节，此时请使用 KEEP()，比如 KEEP(*(.init)) 或 KEEP(SORT_BY_NAME(*)(.ctors)). 输入节示例 请参考Input Section Example 输出节数据 项目中暂时用不到，可以参考文档自行理解。 输出节关键词 项目中暂时用不到，可以参考文档自行理解。 输出节丢弃 项目中暂时用不到，可以参考文档自行理解。 输出节属性 项目中暂时用不到，可以参考文档自行理解。 覆盖描述 项目中暂时用不到，可以参考文档自行理解。 其余命令 除此之外，还有 MEMORY、PHDRS、VERSION 命令可供使用，项目中暂时用不到，可以参考文档自行理解。 链接脚本中的表达式 链接脚本语言中表达式的语法与 C 表达式的语法相同，只是在某些地方需要空格来解决语法歧义。所有表达式都作为整数计算。所有表达式都以相同的大小计算，如果主机和目标都是 32 位，则为 32 位，否则为 64 位。 可以在表达式中使用和设置符号值。 链接器定义了几个在表达式中使用的专用内置函数。 项目中暂时用不到，可以参考文档自行理解。 隐式链接脚本 如果指定了链接器输入文件，但链接器无法将其识别为目标文件或库文件，那么将尝试将该文件读取为链接脚本。如果无法将文件解析为链接脚本，则链接器将报告错误。 隐式链接脚本不会替换默认链接脚本。 通常，隐式链接脚本只包含符号赋值，或 INPUT、GROUP、VERSION 命令。 由隐式链接脚本而读取的任何输入文件都将在读取隐式链接脚本的命令行位置读取。这可能会影响库的搜索。 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"interrupt/":{"url":"interrupt/","title":"中断","keywords":"","body":"移植至全志哪吒 D1 开发板 哪吒 D1 开发板使用了全套全志的 sunxi 硬件设备，关于哪吒 D1 所用的硬件设备，我们都需要参考全志官网给出的D1_User_Manual_V0.1(Draft Version)。 D1 的中断控制器采用与 QEMU 相同的 clint + plic 的设计，因此移植工作量就少了很多。 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"interrupt/plic.html":{"url":"interrupt/plic.html","title":"PLIC","keywords":"","body":"PLIC 规范 RISC-V Platform-Level Interrupt Controller Specification 这个文档包含了 RISC-V 平台级中断控制器 (PLIC) 规范，它定义了一个专门设计用于在 RISC-V 系统上下文中工作的中断控制器。PLIC 多路复用各种设备在 HART 上下文的外部中断行中断，具有用于中断优先级的硬件支持。 本规范定义了常规 PLIC 架构和操作参数。PLIC 支持高达 1023 个中断（0 保留）和 15872 个上下文，但实际的中断数量和上下文取决于 PLIC 实现。但是，具体实现中每个寄存器的偏移量需要遵循标准。声称符合标准的 PLIC 应遵循以下部分中提到的实现。 所谓上下文是指在特定 RISC-V 处理器实例中的特定 HART 中的特定权限模式。例如，在具有双路超线程的 4 核系统中，您有 8 个 HART，并且每个 HART 可能至少有两种特权模式：M 模式和 S 模式。（引用） PLIC 如何组织上下文（HART 和特权模式）的中断超出了 RISC-V PLIC 规范范围，但它必须在厂家的 PLIC 规范中规定。 RISC-V PLIC 操作参数 本规范中定义了通用 PLIC 操作参数寄存器块，它们是： 中断优先级配置寄存器：每个中断源的中断优先级。 中断等待位寄存器：每个中断源的中断等待（待处理）状态。 中断使能寄存器：设置启用每个上下文的中断源。 优先级阈值寄存器：每个上下文的中断优先级阈值。 中断请求寄存器：可读取每个上下文的中断源 ID。 中断完成寄存器：中断完成后向相关寄存器写入信息。 这些寄存器都是 32 位宽。 中断优先级 如果 PLIC 支持中断优先级，则可以通过写入其中断优先级配置寄存器来为每个 PLIC 中断源分配优先级。优先级值为 0 被保留为禁用中断。优先级 1 是最低优先级，而最大优先级取决于 PLIC 实现。全局中断的优先级相同时，中断源 ID 小的具有更高优先级。 中断优先级配置寄存器组相对于 PLIC 基地址的偏移是 0，组中寄存器的个数与中断源个数相同，第 n 个寄存器中的数字即为 n 号中断源的优先级。 等待（待处理）中断位 某一中断源的等待状态可以从等待寄存器组中读出，读取方法是将所有等待寄存器连起来视作一个元素大小为 1 位的数组，第 n 号中断源的待处理位存储在第 n / 32 个寄存器的第 n % 32 位中。（其中第 0 个寄存器的位 0 表示不存在中断源 0，被硬连线为 0。） 当 IP 位为 1 时，表示当前该外部中断源存在等待响应的中断。该位可通过内存存储指令 (SW 指令） 置 1。在对应中断源采样逻辑采样到有效电平或脉冲中断后也会将该位置 1。 当 IP 位为 0 时，表示当前该外部中断源没有等待响应的中断。该位可通过内存存储指令 (SW 指令）清 0。当中断被响应后，PLIC 也会将对应中断的 IP 位清除。 中断等待寄存器组相对于 PLIC 基地址的偏移是 0x001000。 中断使能 通过在使能寄存器中设置相应的位，可以启用各个全局中断。使能寄存器的访问方式与等待寄存器相同。（其中第 0 个寄存器的位 0 表示不存在中断源 0，被硬连线为 0。） PLIC 具有 15872 个上下文的中断使能寄存器组。 当 IE 位为 1 时，表示中断对该目标使能。 当 IE 位为 0 时，表示中断对该目标屏蔽。 中断使能寄存器组相对于 PLIC 基地址的偏移是 0x002000，且首先是上下文 0 的所有中断源的使能位，随后是按顺序上下文 1 到上下文 15871 的所有中断使能位。内存布局如下： 0x002000: Interrupt Source #0 to #31 Enable Bits on context 0 ... 0x00207F: Interrupt Source #992 to #1023 Enable Bits on context 0 0x002080: Interrupt Source #0 to #31 Enable Bits on context 1 ... 0x0020FF: Interrupt Source #992 to #1023 Enable Bits on context 1 0x002100: Interrupt Source #0 to #31 Enable Bits on context 2 ... 0x00217F: Interrupt Source #992 to #1023 Enable Bits on context 2 0x002180: Interrupt Source #0 to #31 Enable Bits on context 3 ... 0x0021FF: Interrupt Source #992 to #1023 Enable Bits on context 3 ... 0x1F1F80: Interrupt Source #0 to #31 on context 15871 ... 0x1F1F80: Interrupt Source #992 to #1023 on context 15871 我们的开发板 D1 只有单核单线程，2 种中断的特权模式，因此有 2 个上下文。虽然只支持最多 256 个中断源，但是由于要和 PLIC 标准所规定的内存布局一致，因此 1 号上下文的使能寄存器组（PLIC Superuser Mode Interrupt Enable Register n）的偏移依然需要从 0x2080 开始。 优先级阈值 PLIC 提供基于上下文的中断阈值寄存器，用于每个上下文的中断优先级阈值的设置。阈值寄存器是一个 WARL 字段。PLIC 将屏蔽优先级小于或等于阈值的所有 PLIC 中断。例如，阈值为 0 意味着允许所有非零优先级中断。 WARL 字段：指这个寄存器可以写任意值，但只有在值合法的时候才会被真正写入。 中断优先级阈值寄存器组相对于 PLIC 基地址的偏移是 0x200000，并且每个寄存器要求 4K 对齐（实际来说，就是每个寄存器地址是前一个寄存器加 0x1000）。 内存布局如下： 0x200000: Priority threshold for context 0 0x201000: Priority threshold for context 1 0x202000: Priority threshold for context 2 0x203000: Priority threshold for context 3 ... 0x3FFF000: Priority threshold for context 15871 中断响应过程 当 PLIC 对特定中断目标存在有效中断请求，且优先级大于该中断目标的中断阈值时，会向该中断目标发起中断请求。 当该中断目标收到中断请求，且可响应该中断请求时，需要向 PLIC 发送中断响应消息。中断响应机制如下： 中断目标（即上下文，某一 HART 的某一特权级）向其对应的中断响应/完成寄存器发起一个读操作。该读操作将返回一个 ID，表示当前 PLIC 仲裁出的中断 ID。中断目标根据所获得的 ID 进行下一步处理。如果获得的中断 ID 为 0，表示没有有效中断请求，中断目标结束中断处理。 当 PLIC 收到中断目标发起的读操作，且返回相应 ID 后，会将该 ID 对应的中断源等待位清 0，且在中断处理完成之前屏蔽该中断源的后续采样。 PLIC 可以随时执行响应过程，并且响应操作不受优先级阈值寄存器的设置的影响（此时相当于手动轮询所有可中断外设，而不是真正的中断）。 中断响应寄存器组是基于上下文的，相对于 PLIC 基地址的偏移是 0x200000，并且每个寄存器要求 4K 对齐后+4（实际来说，就是每个寄存器地址是前一个寄存器加 0x1000，且第一个寄存器偏移为 0x200004） 中断完成 完成中断处理程序后，中断目标向中断响应/完成寄存器发起写操作，写入本次完成的中断 ID。如果中断类型为电平中断，需要在此之前清除外设中断源的有效中断信息。 PLIC 收到该中断完成请求后，更新中断响应/完成寄存器，解除 ID 对应的中断源采样屏蔽，结束整个中断处理过程。 PLIC 不检查完成的中断号是否与该目标最后一个响应的中断号相同。如果完成的中断号与该目标的已开启中断号不匹配，则会被忽略。 中断完成寄存器是基于上下文的，并且与中断响应过程中的寄存器地址相同。 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"interrupt/uart.html":{"url":"interrupt/uart.html","title":"UART","keywords":"","body":"驱动 UART 介绍 通过读取设备树信息，我们可以知道 QEMU 使用的 UART 设备与 ns16550a 兼容，阅读全志哪吒 D1 开发板的文档可知它的 UART 设备与 ns16550a 不完全兼容（请注意下文具体提到之处）。因此我们参考 ns16550a 的文档编写两者的驱动程序。其中对于 D1 开发板，我们暂时只关注 UART0，也就是主板上的调试接口。 // QEMU Device Tree uart@10000000 { interrupts = ; interrupt-parent = ; clock-frequency = \"\\08@\"; reg = ; compatible = \"ns16550a\"; }; 关于 ns16550a，这里主要参考 Serial UART information、D1_User_Manual_V0.1(Draft Version)与龙芯 1C300 处理器用户手册 1.4 版，其中龙芯 1C300 中所用 UART 芯片也是 16550a 兼容芯片，可供参考。 UART 全称通用异步接收发射器，它提供与外部设备、调制解调器（数据载波设备、DCE）的异步串行通信。它将外设接收的数据进行串-并行转换，并将转换后的数据传输到内部总线。它也将传输到外设的数据执行并-串行转换。 FIFO 是“First-In First-Out”的缩写，在此处语境下，它是一个具有先入先出特点的缓冲区，设计目的是提高串口的通讯性能，避免频繁进入中断占用CPU资源，或因如果没有及时读走数据，下一个字节数据覆盖先前数据，导致数据丢失。 使用 FIFO，可以在连续收发若干个数据后才产生一次中断，然后一起进行处理，提高接收效率，缺点是实时性受影响。如果 FIFO 中的数据没有达到指定长度而无法产生中断，可以利用接收超时中断，即在一定的时间内没有接收到数据会进入中断，把不足 FIFO 长度的数据读取完。 解决实时性的问题：保持一个字节进一次接收中断，以保证实时性。把 FIFO 打开，在接收中断处理完后去判断缓冲区中是否仍有数据，若有则继续读入，防止数据丢失，此时不会有数据过短无法产生中断的问题。 D1 开发板的 UART 芯片有以下几个特性： 兼容 16550 UART 有两个独立的 FIFO：接收 FIFO 和发送 FIFO，UART0 中每个都是 64 bytes 从 APB 总线时钟获得工作参考时钟（忽略） RS-232 字符的 5 到 8 位数据位，或 RS-485 格式的 9 位 支持 1、1.5 或 2 位停止位 可编程的校验（奇校验、偶校验或不校验） 支持 DMA 支持软件/硬件流控制 寄存器及数据结构设计 寄存器参考 D1 文档第 9.2.5 节寄存器列表与 9.2.6 节寄存器描述。 QEMU：只有从 UART_RBR 到 UART_LSR 的寄存器，我们使用全部这些寄存器。 寄存器宽度为 8bit 其余寄存器均为全志平台特有 全志平台：对于全志平台我们只使用从 UART_RBR 到 UART_LSR 的寄存器与 UART_HALT 寄存器。 寄存器宽度为 32bit，但此处所使用的寄存器均只有低 8 位有效（兼容 16550a） // QEMU struct uart_16550a_regs { uint8_t RBR_THR_DLL; // 0x00, Receiver Buffer Register/Transmitter Holding Register/Divisor Latch LSB uint8_t IER_DLM; // 0x01, Interrupt Enable Register/Divisor Latch MSB uint8_t IIR_FCR; // 0x02, Interrupt Identification Register/FIFO Control Register uint8_t LCR; // 0x03, Line Control Register uint8_t MCR; // 0x04, Modem Control Register uint8_t LSR; // 0x05, Line Status Register }; // D1 board struct uart_sunxi_regs { uint32_t RBR_THR_DLL; // 0x00, Receiver Buffer Register/Transmitter Holding Register/Divisor Latch LSB uint32_t IER_DLM; // 0x04, Interrupt Enable Register/Divisor Latch MSB uint32_t IIR_FCR; // 0x08, Interrupt Identification Register/FIFO Control Register uint32_t LCR; // 0x0c, Line Control Register uint32_t MCR; // 0x10, Modem Control Register uint32_t LSR; // 0x14, Line Status Register uint32_t padding1[(0x007C-0x18)/4]; uint32_t USR; // 0x007C, UART Status Register uint32_t padding2[(0x00A4-0x80)/4]; uint32_t HALT; // 0x00A4, UART Halt TX Register }; 具体寄存器格式请参考 D1_User_Manual_V0.1(Draft Version) 第 899 至 927 页。这里根据几个比较重要的功能和设置来介绍一些寄存器。 RBR 是 UART 模式下串行输入端口上接收的数据。仅当 UART_LSR 中的数据就绪（DR）位为 1 时数据有效。如果在 FIFO 模式，则该寄存器访问接收 FIFO 的头部。THR 是在 UART 模式下的串行输出端口上发送的数据。对于这两个寄存器，当 FIFO 已满时，后续到来的数据会丢失。 DLL 寄存器存放分频除数的低位，DLM 寄存器存放分频除数的高位。 中断使能寄存器（IER） 要想使 16550a 能产生中断，需要将 IER 寄存器的对应为置 1。 位域 位域名称 位宽 访问 描述 7:4 Reserved 4 读/写 保留(全志平台有额外功能，忽略) 3 EDSSI 1 读/写 Modem 状态改变中断使能 2 ELSI 1 读/写 接收器线路状态改变中断使能 1 ETBEI 1 读/写 发送保存寄存器为空中断使能 0 ERBFI 1 读/写 接收有效数据中断使能 中断标识寄存器（IIR） 中断标识寄存器的格式如下： 位域 位域名称 位宽 访问 描述 7:6 FEFLAG 2 读 00:未启用 FIFO, 11:已启用 FIFO, 01: FIFO 不可用 5:4 Reserved 2 读 保留 3:1 IID 3 读 中断源表示位，详见下表 0 INTp 1 读 中断待处理位，0 表示有中断待处理(全志平台配合 IID 域有额外功能，如 3:0 为 0111 则表示 UART 控制器正忙，无法写入配置，需要使用 CHCFG_AT_BUSY，见下文) 16550a 可产生 5 种中断，这 5 种中断的发生由上述 IER 寄存器的位控制： 中断源表示位 优先级（1 为最高） 中断类型 中断源 清除中断方法 需开启的 IER 中断 011 1 接收线路状态改变 (Receiver line status interrupt) 线路状态改变（奇偶、溢出或帧错误，或打断中断） 读 LSR 接收器线路状态中断使能 010 2 接收到有效数据 (Receiver data interrupt) 接收 FIFO 字符个数达到触发阈值 接收 FIFO 的字符个数低于触发阈值 接收有效数据中断使能 110 2 接收超时 (Character Timeout Indication) 在FIFO 至少有一个字符，但在 4 个字符时间内没有任何操作，包括读和写操作 读接收 FIFO 接收有效数据中断使能 001 3 发送保存寄存器为空 (Transmitter holding register empty) 发送保存寄存器为空 写数据到 THR 或读 IIR 发送保存寄存器为空中断使能 000 4 Modem 状态改变 (Modem status interrupt) MSR 寄存器改变 读 MSR Modem 状态中断使能 FIFO 控制寄存器（FCR） 这个寄存器主要控制 FIFO 的设置与清除。 位域 位域名称 位宽 访问 描述 7:6 TL 2 写 接收 FIFO 中断的发生阈值，'00': 1 字节, '01': 1/4满(QEMU: 4B, 全志: 16B), '10': 1/2满(QEMU: 8B, 全志: 32B), '11':距满差 2 字节(QEMU: 14B, 全志: 62B) 5:3 Reserved 3 写 保留(全志平台有额外功能，忽略) 2 Txset 1 写 写 1 以清除发送 FIFO 的内容，复位其逻辑 1 Rxset 1 写 写 1 以清除接收 FIFO 的内容，复位其逻辑 0 FIFOE 1 写 FIFO 使能位，'1': 开启 FIFO, '0': 关闭 FIFO。改变此位会自动复位 FIFO 线路控制寄存器（LCR） 这个寄存器主要控制寄存器访问与收发时数据帧的格式，包括校验、停止位与字符的长度。 位域 位域名称 位宽 访问 描述 7 dlab 1 读/写 分频锁存器访问位, '1': 访问操作分频锁存器, '0': 访问操作正常寄存器 6 bcb 1 读/写 打断控制位, '1': 此时串口的输出被置为 0(打断状态), '0': 正常操作 5 spb 1 读/写 指定奇偶校验位, '0': 正常奇偶校验, '1': 校验位恒为 LCR[4] 取反 4 eps 1 读/写 奇偶校验位选择, '0': 奇校验, '1': 偶校验 3 pe 1 读/写 奇偶校验位使能, '0': 没有奇偶校验位, '1': 在发送时生成奇偶校验位，接收时检查奇偶校验位 2 sb 1 读/写 停止位的位数, '0': 1 个停止位, '1': 在 5 位字符长度时是 1.5 个停止位，其他长度是 2 个停止位 1:0 bec 2 读/写 设定每个字符的位数, '00': 5 位, '01': 6 位, '10': 7 位, '11': 8 位 线路状态寄存器（LSR） 位域 位域名称 位宽 访问 描述 7 ERROR 1 R 错误表示位, '1': 至少有奇偶校验位错误，帧错误或打断中断的一个, '0': 没有错误 6 TE 1 R 发送为空且线路空闲表示位, '1': 发送寄存器/FIFO 和发送移位寄存器都为空, '0': 有数据 5 THRE 1 R 发送寄存器/FIFO 为空表示位, '1': 当前发送寄存器/FIFO 为空, '0': 有数据 4 BI 1 R 打断中断表示位, '1': 接收到 起始位＋数据＋奇偶位＋停止位都是 0，即有打断中断, '0': 没有打断 3 FE 1 R 帧错误表示位, '1': 接收的数据没有停止位, '0': 没有错误, 读取 LSR 寄存器后自动清空 2 PE 1 R 奇偶校验位错误表示位, '1': 当前接收数据有奇偶错误, '0': 没有奇偶错误, 读取 LSR 寄存器后自动清空 1 OE 1 R 数据溢出表示位, '1': 有数据溢出, '0': 无溢出, 读取 LSR 寄存器后自动清空 0 DR 1 R 接收数据有效表示位, '0': 在 FIFO 中无数据, '1': 在 FIFO 中有数据 其余寄存器如 MCR、MSR 我们用不到，就不再介绍。 UART 操作模式 数据帧格式 UART_LCR 寄存器可以设置数据帧的基本参数：数据宽度(5-8 bits)、停止位（1、1.5 或 2 位停止位）、校验形式。 UART 的帧传输包括启动信号、数据信号、奇偶校验位和停止信号。最低有效位（LSB）首先传输。 开始信号（开始位）：数据帧的开始标志。根据 UART 协议，开始位传输信号为低电平。 数据信号（数据位）：数据位宽度可以配置为 5 - 8 位。 奇偶校验位：1 位的错误校正信号。奇偶校验位可通过 UART_LCR 设置奇校验、偶校验或无校验。 停止信号（停止位）：数据帧的停止位。UART_LCR 寄存器可以设置停止位为 1 位、1.5 位或 2 位。结束位传输信号为高电平。 波特率 波特率计算如下：波特率 = SCLK /（16 除数）。D1 开发板中，SCLK 通常是 APB1，可在 CCU 中设置。* 其中除数（divisor, 分频）有 16 位，低 8 位在 UART_DLL 寄存器中，高 8 位在 UART_DLH 寄存器中。 如果要设置波特率为 115200，时钟源的频率为 24 MHz，根据公式可得除数约为 13. DLAB 定义 UART_LCR 的第 7 位为 DLAB(Divisor Latch Access Bit)，控制分频锁存器的访问。 DLAB = 0，第一、二个寄存器是 UART_RBR/UART_THR (RX/TX FIFO) 寄存器、UART_IER 寄存器。 DLAB = 1，第一、二个寄存器是 UART_DLL（除数低位）寄存器、UART_DLH（除数高位）寄存器 初始化设置除数时须设 DLAB = 1，结束配置时须设 DLAB = 0 以便访问数据。 CHCFG_AT_BUSY 定义（全志平台特有，不能忽略，否则初始化会出错） CHCFG_AT_BUSY（UART_HALT[1]）和 CHANGE_UPDATE（UART_HALT[2]）的功能如下。 CHCFG_AT_BUSY：启用该位，则软件可以在 UART 繁忙时依然设置 UART 控制器，例如 UART_LCR、UART_DLH、UART_DLL 寄存器。 CHANGE_UPDATE：如果启用了 CHCFG_AT_BUSY，并将 CHANGE_UPDATE 写入 1，则 UART 控制器的设置会被更新。完成更新后，位会自动清除到 0。 设置除数应执行以下步骤： 设 CHCFG_AT_BUSY = 1 设 DLAB = 1 并设置 UART_DLH 与 UART_DLL 寄存器 设 CHANGE_UPDATE = 1 以更新配置，更新完成后将会自动被设为 0 UART 忙标志位（全志平台特有） UART_USR[0] 是 UART 控制器的忙标志位。当有收发数据时，或 FIFO 不为空时，忙标志位就会被自动设为 1，表明 UART 控制器正忙。 程序设计 UART 控制器初始化 I/O 配置(全志平台特有，忽略)：将 GPIO 多路复用配置为 UART 功能，并将 UART 引脚设置为内部上拉模式。 等待发送缓冲区清空（所有数据发送完） 设置 UART_IER = 0 以关闭所有 UART 中断，避免在未设置完成时就触发中断。 波特率配置: 计算 UART 波特率 设置 UART_HALT[HALT_TX] = 1 以禁用发送（全志平台特有） 设置 UART_HALT[CHCFG_AT_BUSY] = 1 使得 DLL 和 DLM 可以被写入（全志平台特有） 设置 UART_LCR[DLAB] = 1，其他位保留默认配置，使第一第二个端口进入波特率设置模式以访问分频锁存器 访问 UART_USR[BUSY] 位，直到其变为 0，等待到 UART 控制器不忙（全志平台特有） 向 UART_DLH 寄存器写入分频的高八位，向 UART_DLL 寄存器写入分频的低八位 设置 HALT[CHANGE_UPDATE] = 1，使得 DLL 和 DLM 被更新（全志平台特有） 等待 HALT[CHANGE_UPDATE] 位置 0，表示 DLL 和 DLM 已经被读取（全志平台特有） 设置 UART_HALT[HALT_TX] = 0 以启用发送（全志平台特有） 控制参数配置： 写入 UART_LCR 以设置数据宽度、停止位、奇偶校验方式，并写 UART_LCR[DLAB] = 0，恢复正常模式 写入 UART_FCR 寄存器设置 FIFO 触发条件并启用 FIFO 中断配置： 设置 UART_IER[ERBFI] = 1 以打开接收有效中断 上面的等待部分需要通过轮询来查询状态，否则几乎必然会有问题，由此可见 D1 开发板的 UART 速度很慢，我们需要不断地确保所有操作已经完成。 代码如下： // QEMU init static void uart_16550a_init() { volatile struct uart_qemu_regs *regs = (struct uart_qemu_regs *)uart_device.uart_start_addr; regs->IER_DLM = 0; // 关闭 16550a 的所有中断，避免初始化未完成就发生中断 while(!(regs->LSR & (1 > 8; regs->LCR |= 1 IER_DLM = divisor_most; // 设置 DLM regs->RBR_THR_DLL = divisor_least; // 设置 DLL regs->LCR = 0b00000011; // 一次传输 8bit（1字节），无校验，1 位停止位，禁用 break 信号，设置 DLAB=0，进入数据传输/中断设置模式 regs->IIR_FCR |= 0b00000001; // 设置 FCR[TL]=00，设置中断阈值为 1 字节，设置 FCR[FIFOE]=1，启动 FIFO regs->IER_DLM |= 1 // D1 board init static void uart_16550a_init() { volatile struct uart_sunxi_regs *regs = (struct uart_sunxi_regs *)uart_device.uart_start_addr; regs->IER_DLM = 0; // 关闭 16550a 的所有中断，避免初始化未完成就发生中断 while(!(regs->LSR & (1 > 8; regs->HALT |= 1 HALT |= 1 LCR |= 1 USR & 1 RBR_THR_DLL = divisor_least; // 设置 DLL regs->IER_DLM = divisor_most; // 设置 DLM regs->HALT |= 1 HALT & (1 HALT &= ~(1 LCR = 0b00000011; // 一次传输 8bit（1字节），无校验，1 位停止位，禁用 break 信号，设置 DLAB=0，进入数据传输/中断设置模式 regs->IIR_FCR |= 0b00000001; // 设置 FCR[TL]=00，设置中断阈值为 1 字节，设置 FCR[FIFOE]=1，启动 FIFO regs->IER_DLM |= 1 轮询模式下发送数据 在我们的实验中 UART 一次发送的量通常较小，因此选择简单的轮询模式发送数据。 检查 UART_LSR[THRE] 以检查发送 FIFO 是否为空。若 UART_LSR[THRE] = 0，则表明发送 FIFO 中的仍有数据，等待数据传输完成 写入将要被传送的数据至 UART_THR 寄存器 代码如下： void uart_16550a_directly_write(int8_t c) { regs->RBR_THR_DLL = c; /* write THR */ } void uart_16550a_putc(int8_t c) { while (!(regs->LSR & (1 中断模式中接收数据 设置 UART_IER[ERBFI] = 1 以启用 UART 接收中断 当接收 FIFO 的数据达到触发条件时（如达到触发阈值或超时)，UART 接受中断信号将会产生 读取 UART_LSR[DR] 检查 RX_FIFO 状态，若该位为 1，继续从 UART_RBR 读取数据，直至该位变为 0，接收结束 同时我们在中断发生时发送接收到的字符，代码如下： int8_t uart_16550a_read() { return regs->RBR_THR_DLL; /* read RBR */ } // QEMU interrupt handler void uart_16550a_interrupt_handler() { while (regs->LSR & (1 -1) uart_16550a_putc(c); } } 对于 D1 开发板，在初始化写入分频除数时会产生一个 UART busy 中断，需要在中断处理程序中处理： // D1 board interrupt handler static void uart_16550a_interrupt_handler() { volatile struct uart_sunxi_regs *regs = (struct uart_sunxi_regs *)uart_device.uart_start_addr; if ((regs->IIR_FCR & IIR_IID_MASK) == UART_BUSY_VALUE) // 处理有时仍可能会发生的 UART busy 中断，标志是 UART_IIR 寄存器的低 4 位为 0111 regs->USR; // 处理方法是读取 regs->USR 以清除中断 while (regs->LSR & (1 -1) uart_16550a_putc(c); } } By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"interrupt/goldfish_RTC.html":{"url":"interrupt/goldfish_RTC.html","title":"RTC","keywords":"","body":"驱动 QEMU 的 RTC 介绍 寄存器数据结构设计 在这里，我们使用结构体 struct goldfish_rtc_regs 来表示这些寄存器偏移，使结构体成员变量在内存中的布局与硬件端口相对起始地址的偏移的布局一致。随后将硬件的起始地址强制类型转换后赋值给 struct goldfish_rtc_regs * 结构体指针的一个变量，这样就可以通过结构体中每个成员变量的偏移来表示硬件的对应端口了。 程序设计 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"interrupt/sunxi_plic.html":{"url":"interrupt/sunxi_plic.html","title":"驱动全志哪吒 D1 开发板的 PLIC","keywords":"","body":"驱动全志哪吒 D1 开发板的 PLIC 基本介绍 请优先参考 PLIC 规范，哪吒 D1 的 PLIC 基本是其子集，部分寄存器命名有些许不同，可以通过地址或者描述来判断。（除PLIC Control Register外） 以下内容主要参考、摘录自 D1_User_Manual_V0.1(Draft Version) 的 3.8 节与玄铁 C906 R1S0 用户手册第十章。 PLIC 仅用于外部中断源的采样，优先级仲裁和分配。 外部中断源采样，优先仲裁和分配 中断可以配置为 M 模式和 S 模式 最多 256 个中断源采样，支持中断优先级和脉冲中断 32 个中断优先级 为每个中断模式（M/S）独立维护中断使能 为每个中断模式（M/S）独立维护中断阈值 可配置 PLIC 寄存器的访问权限 PLIC 寄存器列表如下表所示： PLIC Priority Register n 是设置第 n 个中断源优先级的寄存器，可读可写。此处全志的文档表格有误，每个寄存器低 5 位均有效，值范围在 [0,31]。 sunxi_plic 支持 32 种不同的优先级，其中，机器模式中断优先级无条件高于超级用户模式中断。当中断目标模式相同时，优先级 1 为最低优先级，优先级 31 为最高。当多个优先级相同的中断等待仲裁时，进一步比较中断源 ID，ID 较小的有高优先级。 PLIC Interrupt Pending Register n 是指示中断是否发生待处理的寄存器。 PLIC Machine Mode Interrupt Enable Register n 是指示 M 模式中断使能的寄存器。 PLIC Superuser Mode Interrupt Enable Register n 是指示 S 模式中断使能的寄存器。 我们的开发板 D1 只有单核单线程，2 种中断的特权模式，因此有 2 个上下文。虽然只支持最多 256 个中断源，但是由于要和 PLIC 标准所规定的内存布局一致，因此 1 号上下文的使能寄存器组（PLIC Superuser Mode Interrupt Enable Register n）的偏移依然需要从 0x2080 开始，下面最后四个寄存器同理。 注意：此处 PLIC Control Register 与 PLIC 标准不同： PLIC Control Register 是 PLIC 的访问权限控制寄存器。 最低位为 0 表示只有 M 模式可以访问 PLIC 的所有寄存器，S 模式不能访问PLIC_CTRL, PLIC_PRIO, PLIC_IP 与 PLIC_IE 寄存器，只能访问中断阈值寄存器和中断响应、完成寄存器，U 模式不能访问任何 PLIC 寄存器。 最低位为 1 表示 M 模式可以访问 PLIC 的所有寄存器，S 模式不能访问 PLIC_CTRL 寄存器，U 模式不能访问任何 PLIC 寄存器。 PLIC Machine Threshold Register 是 M 态的阈值寄存器。 PLIC Machine Claim Register 是 M 态的响应/完成寄存器。 PLIC Superuser Threshold Register 是 S 态的阈值寄存器。 PLIC Superuser Claim Register 是 S 态的响应/完成寄存器。 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"interrupt/sunxi_RTC.html":{"url":"interrupt/sunxi_RTC.html","title":"驱动全志哪吒 D1 开发板的 RTC","keywords":"","body":"驱动全志哪吒 D1 开发板的 RTC 介绍 在D1_User_Manual_V0.1(Draft Version)中，与 RTC 有关的部分主要是 3.14 节对 RTC 的端口与使用方式的具体说明。因此这篇文章主要还是对文档的翻译与说明，其次是在我们的操作系统中编写符合接口规范的代码。 哪吒 D1 使用了全套全志的 sunxi 硬件设备，RTC 模块被称为 sunxi-rtc。 阅读文档 3.14.1 节，可以了解到这是一个记录日历型时间的 RTC 设备，这与 QEMU 上使用的 Goldfish RTC 所采用的记录 UNIX 时间戳的 RTC 有很大的不同。 实时时钟（RTC）用于实现时间计数器和定时唤醒功能。RTC 可以实时显示年、月、日、周、时、分、秒。RTC 有独立的电源在系统断电时继续工作。 RTC 具有以下功能： 提供用于计日的 16 位计数器，计小时的 5 位计数器，计分钟的 6 位计数器，计秒的 6 位计数器 外部连接一个 32.768 kHz 低频振荡器，用于计时 定时器频率为 1 kHz 随时可通过软件配置初始值 支持定时警报，并生成中断，唤醒外部设备 8 个 32 位用户寄存器，用于存储 关机信息 注意：RTC 的寄存器配置是 AHB 总线，它只可以支持按字操作，不可按字节操作和半字操作 小知识 D1 的 RTC 时钟树 LOSC_SRC_SEL: LOSC 有 2 个时钟源：内部 RC 与外部低频晶振。启动时默认选择内部 RC，也可通过软件选择外部低频晶振以提供更精确的时钟。LOSC 的时钟精确与外部低频晶振的精确有关。通常选择 32.768 kHz 具有 ±20 ppm 频率公差的晶振。使用内部 RC 时，可以通过更改分频比率（图中/N）来更改时钟。使用外部时钟时，无法更改时钟。 RTC： RTC 的时钟源可以通过相关开关选择，包括由内部 16 MHz RC 分频所得的 32K 信号、外部 DCXO 分频所得的 32K 信号与外部 32.768 kHz 晶振产生的信号。随后被图中/32分频器分频得到 1kHz 的输入信号 System 32K： 系统 32K 的时钟源来自外部 32.768 kHz 晶振信号，或内部 16 MHz 分频出的 32K 信号。 RTC_32K_FANOUT： RTC_32K_FANOUT 的时钟源可以选择 CLK32K（系统 32K 的来源）、外部 32.768 kHz 晶振或外部 DCXO 分频所得的 32k 信号。随后通过引脚直接引出。 工作原理 时钟 RTC 模块从外部获得 1kHz 的输入源，随后在模块内计数，每计数 1000 次在计秒计数器上加 1，随后按层级依次更新计分计数器、计小时计数器、计日计数器。这些计数器的范围分别为 [0,59]、[0,59]、[0,23]、[0,65535]。 注意：这些计数器没有硬件纠错机制，因此不应该向其中写入不合理的值。 sunxi_rtc 没有年、月计数器，因此需要通过日计数器来计算，但是我们的 RTC 接口设定与读取日期的参数都是时间戳，因此我们设计时不需要考虑年月的计算。 闹钟 闹钟本质上是一个比较器，当时钟达到闹钟设定值时，闹钟就会发出中断信号，或者通过 NMI 引脚输出低级信号唤醒电源管理芯片（可用于定时开机）。 每次中断发生时，需要重设闹钟时间才能继续发出下一次中断。 小知识 关机时信息存储： RTC 提供 8 个 32 位通用寄存器来存储断电信息。 由于 VCC-RTC 冷启动后始终保持非断电状态，因此当系统处于关机或待机状态时，CPU 可以通过存储信息判断软件进程。 寄存器数据结构设计 这里的寄存器指的是硬件的端口。 寄存器参考 D1 文档第 3.14.5 节寄存器列表与 3.14.6 节寄存器描述，其中我们只需使用从偏移 0x0000 开始的 LOSC_CTRL_REG 寄存器到 0x0050 开始的 ALARM_CONFIG_REG 寄存器，其余寄存器多为电器参数控制和其他硬件参数相关的控制，我们用不到，也不需要修改。 和 goldfish_rtc 的设计一样，我们也是用结构体来表示这些寄存器偏移。 阅读 3.14.6 节寄存器描述，会发现我们需要用的寄存器都是 32bit 的，因此可以使用 uint32_t 作为各个寄存器变量的类型。但是注意这些寄存器之间是不连续的，因此要在不连续的部分插入占位成员变量，以确保结构体的布局与真实硬件端口地址偏移的布局是相同的。 代码如下： 注：混合使用 uint32_t 与 uint64_t 可能会因为内存对齐导致编译器自动填充未对齐的部分，如果使用 gcc 编译器，可以使用 struct __attribute__((__packed__)) sunxi_rtc_regs 来禁用对齐，这里建议全部使用 uint32_t 添加占位成员变量。（参考 Structure padding and packing ） struct sunxi_rtc_regs { uint32_t losc_ctrl_reg; // 0x00, losc control register uint32_t losc_auto_swt_sta_reg; // 0x04, losc auto switch status register uint32_t intosc_clk_prescal_reg; // 0x08, intosc clock prescaler register uint32_t padding1; // 0x0c, padding uint32_t rtc_day_reg; // 0x10, rtc day register uint32_t rtc_hh_mm_ss_reg; // 0x14, rtc hour, minute, second register uint32_t padding2[2]; // 0x18, padding uint32_t alarm0_day_set_reg; // 0x20, alarm0 day set register uint32_t alarm0_cur_vlu_reg; // 0x24, alarm0 current value register uint32_t alarm0_enable_reg; // 0x28, alarm0 enable register uint32_t alarm0_irq_en; // 0x2c, alarm0 interrupt enable register uint32_t alarm0_irq_sta_reg; // 0x30, alarm0 interrupt status register, Write 1 to clear uint32_t padding3[7]; // 0x34, padding uint32_t alarm_config_reg; // 0x50, alarm configuration register }; 程序设计 程序设计参考 D1 文档第 3.14.4 节的指南 时间转换 由于 sunxi_rtc 使用了日历型时钟，因此我们需要写两个 UNIX 时间戳与日历型时钟相互转换的函数，这里的原理就略去，直接给出代码： #define SEC_PER_DAY 86400 #define SEC_PER_HOUR 3600 #define SEC_PER_MIN 60 static void timestamp_to_day_hh_mm_ss(uint64_t timestamp, uint32_t *day, uint32_t *hh, uint32_t *mm, uint32_t *ss) { timestamp /= 1000000000; // ns -> s *day = timestamp / SEC_PER_DAY; *hh = timestamp % SEC_PER_DAY / SEC_PER_HOUR; *mm = timestamp % SEC_PER_HOUR / SEC_PER_MIN; *ss = timestamp % SEC_PER_MIN; } static uint64_t day_hh_mm_ss_to_timestamp(uint32_t day, uint32_t hh, uint32_t mm, uint32_t ss) { uint64_t timestamp = day * SEC_PER_DAY + hh * SEC_PER_HOUR + mm * SEC_PER_MIN + ss; return timestamp * 1000000000; // s -> ns } 时钟源控制 选择时钟源：通过 LOSC_CTRL_REG 的位 [0] 选择时钟源，默认时钟源是内部 RC 振荡器。当系统启动时，可以通过软件切换到外部 32K 振荡器。 自动切换：启用 LOSC_CTRL_REG 的位 [15:14] 后，RTC 在外部晶体无法输出波形时自动将时钟源切换到内部振荡器，切换状态可以通过 LOSC_AUTO_SWT_STA_REG 的位 [1] 查询。 注意：如果仅配置 LOSC_CTRL_REG 的位 [15]，则在自动切换生效后无法更改时钟源状态位，因为这两个功能是独立的。 我们不需要时钟源控制功能，所以这一部分仅做了解。 时钟控制 写入时间初始值：将当前时间写入 RTC_DAY_REG 和 RTC_HH_MM_SS_REG。 更新时间后，RTC 重新启动计数。软件可以随时读取当前时间。 注意：在执行设置之前，确保 LOSC_CTRL_REG 的位 [8:7] 为 0。 // D1 文档给出的示例伪代码 // For example: set time to 21st, 07:08:09 and read it. RTC_DAY_REG = 0x00000015; RTC_HH_MM_SS_REG = 0x00070809; //0000 0000 000|0 0000(Hour) 00|00 0000(Minute) 00|00 0000(Second) Read (RTC_DAY_REG); Read (RTC_HH_MM_SS_REG); 其中RTC_DAY_REG 和 RTC_HH_MM_SS_REG 的布局如下： 根据文档，写出读写时钟的函数： uint64_t sunxi_rtc_read_time() { struct sunxi_rtc_regs *regs = (struct sunxi_rtc_regs *)SUNXI_RTC_START_ADDR; uint32_t day = regs->rtc_day_reg; uint32_t hh_mm_ss = regs->rtc_hh_mm_ss_reg; // 根据 3.14.6.4、3.14.6.5 节布局转换天、时、分、秒到时间戳 return day_hh_mm_ss_to_timestamp(day, hh_mm_ss >> 16, (hh_mm_ss >> 8) & 0x3f, hh_mm_ss & 0x3f); } void sunxi_rtc_set_time(uint64_t now) { uint32_t day; uint32_t hh; uint32_t mm; uint32_t ss; struct sunxi_rtc_regs *regs = (struct sunxi_rtc_regs *)SUNXI_RTC_START_ADDR; // 转换时间戳到天、时、分、秒 timestamp_to_day_hh_mm_ss(now, &day, &hh, &mm, &ss); // 首先检测 LOSC_CTRL_REG 的位 [8:7] 是否为 0 if (regs->losc_ctrl_reg & 0x180) { // 如果不为 0，报错 kprintf(\"LOSC_CTRL_REG[8:7] is not 0, cannot set time\\n\"); return; } else { now >>= 9; // ns -> s // 根据 3.14.6.4 节布局修改 RTC_DAY_REG regs->rtc_day_reg = (uint64_t)day; // 根据 3.14.6.5 节布局修改 RTC_HH_MM_SS_REG regs->rtc_hh_mm_ss_reg = hh ALARM0 闹钟控制 通过写 ALARM0_IRQ_EN 启用 alram0 中断。 设置时钟比较器：向 ALARM0_DAY_SET_REG 与 ALARM0_HH-MM-SS_SET_REG （下图中为 ALARM_CUR_VLE_REG) 写入闹钟的日、小时、分钟、秒。 写入 ALARM0_ENABLE_REG 以启用 alarm 0 功能，然后可以通过 ALARM0_DAY_SET_REG 和 ALARM0_HH-MM-SS_SET_REG （下图中为 ALARM_CUR_VLE_REG) 实时查询闹钟时间。当设置时间达到时，ALARM0_IRQ_STA_REG 将被置 1 以生成中断。 在进入中断处理程序后，写入 ALARM0_IRQ_STA_REG 以清除中断，并执行中断处理程序。 恢复中断并继续执行被中断的进程。 断电唤醒由 SoC 硬件和 PMIC 生成，程序仅需要设置 alarm 0 的触发条件，并将 ALARM_CONFIG_REG 设置为 1 即可。 相关寄存器布局如下： // D1 文档给出的示例伪代码 irq_request(GIC_SRC_R_Alarm0, Alm0_handler); irq_enable(GIC_SRC_R_Alarm0); writel(1, ALARM0_DAY_SET_REG); writel(1, RTC_HH_MM_SS_REG); //set 1 second corresponding to normal mode; writel(1, ALM0_EN); writel(1, ALM_CONFIG); //NMI output while(!readl(ALM0_IRQ_STA)); writel(1, ALM0_IRQ_EN); while(readl(ALM0_IRQ_STA)); 根据文档，写出读写闹钟、处理中断以及关闹钟（中断）的函数，注意，alarm0_irq_sta_reg 寄存器是 W1C（Write 1 to clear, 写 1 来清零）的，另外 sunxi_rtc 是在从 x 秒跳到 x+1 秒的那一刹那才会触发设置在 x 秒的闹钟，需要在闹钟设置里面提前一秒： void sunxi_rtc_set_alarm(uint64_t alarm) { uint32_t day; uint32_t hh; uint32_t mm; uint32_t ss; struct sunxi_rtc_regs *regs = (struct sunxi_rtc_regs *)SUNXI_RTC_START_ADDR; // 通过写 ALARM0_IRQ_EN 启用 alram0 中断。 regs->alarm0_irq_en = 1; // 设置时钟比较器：向 ALARM0_DAY_SET_REG 与 ALARM0_HH-MM-SS_SET_REG 写入闹钟的日、小时、分钟、秒。 // 转换时间戳到天、时、分、秒 timestamp_to_day_hh_mm_ss(alarm, &day, &hh, &mm, &ss); alarm >>= 9; // ns -> s // 根据布局修改 ALARM0_DAY_SET_REG regs->alarm0_day_set_reg = (uint64_t)day; // 根据布局修改 ALARM0_HH-MM-SS_SET_REG regs->alarm0_cur_vlu_reg = hh alarm0_enable_reg = 1; } uint64_t sunxi_rtc_read_alarm() { struct sunxi_rtc_regs *regs = (struct sunxi_rtc_regs *)SUNXI_RTC_START_ADDR; // 可以通过 ALARM0_DAY_SET_REG 和 ALARM0_HH-MM-SS_SET_REG （下图中为 ALARM_CUR_VLE_REG) 实时查询闹钟时间。 uint32_t day = regs->alarm0_day_set_reg; uint32_t hh_mm_ss = regs->alarm0_cur_vlu_reg; return day_hh_mm_ss_to_timestamp(day, (hh_mm_ss >> 16) & 0x1f, (hh_mm_ss >> 8) & 0x3f, hh_mm_ss & 0x3f); } void sunxi_rtc_interrupt_handler() { struct sunxi_rtc_regs *regs = (struct sunxi_rtc_regs *)SUNXI_RTC_START_ADDR; // 在进入中断处理程序后，写入 ALARM0_IRQ_STA_REG 以清除中断，并执行中断处理程序。 regs->alarm0_irq_sta_reg = 1; } void sunxi_rtc_clear_alarm() { struct sunxi_rtc_regs *regs = (struct sunxi_rtc_regs *)SUNXI_RTC_START_ADDR; regs->alarm0_irq_en = 0; regs->alarm0_irq_sta_reg = 1; regs->alarm0_enable_reg = 0; } 注册设备 最后和 goldfish_rtc 一样，我们也要将 sunxi_rtc 注册到接口上以便调用。 static const struct rtc_class_ops sunxi_rtc_ops = { .read_time = sunxi_rtc_read_time, .set_time = sunxi_rtc_set_time, .read_alarm = sunxi_rtc_read_alarm, .set_alarm = sunxi_rtc_set_alarm, .rtc_interrupt_handler = sunxi_rtc_interrupt_handler, .clear_alarm = sunxi_rtc_clear_alarm, }; extern struct rtc_class_device rtc_device; void sunxi_rtc_init() { rtc_device.ops = sunxi_rtc_ops; } By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"virtualmm/":{"url":"virtualmm/","title":"虚拟内存管理","keywords":"","body":"虚拟内存 在这一章，我们将会在内存管理中更进一步，开启开启分页，进入虚拟内存管理。 本章对应代码：lab4 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"virtualmm/intro.html":{"url":"virtualmm/intro.html","title":"基础介绍","keywords":"","body":"什么是虚拟内存 直到现在，我们的内核不受限制地跑在 CPU 上，可以直接访问任何一处物理地址。这时假如内核加载并运行用户程序，用户程序可以几乎无限制的读写物理内存。对于恶意程序，它可以杀死其它程序甚至可以杀死内核，将整个系统的资源据为己有；对于遵纪守法的程序，它必须小心翼翼地控制自己，避免无意中修改了其他程序。显然，这种无限制的环境既给了程序自由，又让程序处于随时可能被破坏的境地。 现代操作系统一般都实现了虚拟内存，程序跑在虚拟内存上，不直接访问物理内存，并且每个程序（进程）都有相同的地址空间。应用程序不需要再担心被别的程序破坏或者不小心写了别的程序的内存，也不再需要考虑自己在内存中的哪个位置。 尽管程序跑在虚拟内存上，但是最终一定是访问到物理内存，虚拟内存只是操作系统的抽象。每当程序访问某个虚拟地址，硬件和操作系统会将虚拟地址转化为某个物理地址，然后程序访问到对应的物理内存。显然，实现虚拟内存的关键就在于设置虚拟地址到物理地址的映射。 考虑这样的情况，程序 A 访问虚拟地址 100，程序 B 也访问虚拟地址 100。对于程序 A，操作系统将虚拟地址 100 映射到物理地址 1000；对于程序 B，操作系统将物理地址映射到物理地址 2000。虽然两程序访问同一地址，但最终却访问到物理内存的不同位置。按照这种思路，让不同的程序拥有相同的虚拟地址空间，将其中的虚拟地址映射到不同的物理地址，这样就实现了“每个进程都有相同的地址空间”的抽象。相同虚拟地址可以映射到不同的物理地址，同样的，不同的虚拟地址也可以映射到同一物理地址，这样就实现了不同程序共享同一块内存。 经过以上讨论，相信同学们已经理解了实现虚拟内存的思路。虚拟内存需要软硬件协作才能够高效实现，并且硬件提供的机制制约着操作系统的实现方式，接下来介绍 RISC-V 提供的虚拟内存机制。 RISC-V 中的虚拟内存管理硬件基础 一个相对完整的 RISC-V 处理器通常会带有一个 MMU（内存管理单元）来处理和内存管理相关的事务，虚拟地址到物理地址的转换就由它来实现。RV64 的标准中给出了若干虚拟内存分页方案，以 SvX 的模式命名，其中 X 是以位为单位的虚拟地址的长度，其中最受欢迎的是 Sv39, QEMU 和阿里平头哥的玄铁 RISC-V 芯片都支持这种分页方案，因此我们也采用这种分页方案。 注：玄铁 RISC-V 芯片在官方标准的基础上做了些许修改，将不常用到的字段挪作它用，而 QEMU 中 virt 型的虚拟机则与官方标准相同，我们这里采用官方方案在 QEMU 中实现，如果后期有想做全志 D1 开发版移植的同学请注意修改代码。 启用分页的时候，大多数地址（包括 load 和 store 的有效地址和 PC 中的地址）都是虚拟地址。要访问物理内存，MMU 将读取页表并将物理地址转换为真正的物理地址。 单级页表是一个以页表项为元素的数组，页表项中除了存有对应虚拟地址所指向的物理地址外，还存有读写权限等附加信息。 现代处理器提供的分页机制基本都使用多级页表，将虚拟地址划分多个虚拟页号（VPN, Virtual Page Numer）和页内偏移（offset），RISC-V 的页内偏移均使用 12 位二进制表示（这意味着每一页都是 4KiB）。上一级页表中的页表项（PTE， Page Table Entry）指向下一级页表的起始物理地址，最后一级页表中页表项指向虚拟地址对应的物理地址。将页表看作页表项数组 struct pte page_table[]，某一级 VPN 就是该级页表项数组的索引。以下是查询页表获取物理地址的步骤： 找到一级页表（页目录）的物理地址，这个地址存放在控制寄存器 satp 中 根据 VPN 找到包含下级页表起始物理地址的页表项 重复步骤 2，直到查找到最后一级页表 读取页表项中的物理地址 其中，页表中的叶节点指示虚地址是否已经被映射到了真正的物理页面，如果是，则指示了哪些权限模式和通过哪种类型的访问可以操作这个页。访问未被映射的页或访问权限不足会导致页错误异常（page fault exception）。 这里附上一个二级页表的直观结构与地址转换示意图： 复习一下组成原理： 每次访问内存都要查找页表，查找页表要涉及多次内存访问操作，这会严重影响 CPU 读取指令和读写数据的性能。为了解决这个问题，现代处理器使用了 TLB（Translation-Lookaside Buffer）来加快虚拟地址到物理地址的转换。TLB 是缓存虚拟地址到物理地址映射关系的全相连高速缓存，可以看作一个数组，元素存储映射关系。访问内存时，先从 TLB 中查找物理地址，如果查找到（TLB hit），就不需要查找页表，避免的耗时的内存访问；如果没查找到（TLB miss），再查找页表并将映射缓存进 TLB。良好的程序都会重复利用局部性原理，并且现代处理器还将指令和数据划分开，分别使用独立的 TLB，取指令用 iTLB，读写数据用 dTLB，还可能存在共用的 uTLB，显著提高地址转换的性能。 本内核不对 TLB 进行细粒度的管理，不介绍 TLB 词条的结构。 当页表与 TLB、Cache 配合时的工作流程如下： 分页管理中，每个进程都有自己独立的虚拟地址空间，为了避免进程切换后通过 TLB 访问到上一进程的映射，将虚拟地址转换为错误的物理地址，通常发生进程切换时要刷新 TLB（清除 TLB 缓存）。 satp 寄存器 上面提到，一级页表（页目录）的物理地址存放在控制寄存器 satp 中，它的格式如下： 其中，MODE 表示分页模式，0 表示不采用分页管理（通常 M 模式的程序在第一次进入 S 模式之前会写 0 以禁用分页），没有地址翻译与保护，8 表示采用 Sv39 分页方案。 ASID（Address Space IDentifier) 用来标识 TLB 词条中映射归属的地址空间，ASID 类似于进程 ID，每个进程都有一个 ASID。TLB 中多个进程的虚拟地址-物理地址映射共存，MMU 在查询 TLB 时会忽略不属于当前进程的映射，在进程切换时只需要修改 ASID，不需要刷新 TLB，降低了进程切换的成本。简单起见我们暂不使用 ASID，选择每次切换进程刷新 TLB。 PPN 表示页目录项的物理页号（物理地址右移 12 位）。 WARL 是 Write Any values, Read Legal Values 的简称，表示对应字段可以写入任意值，处理器仅在该字段的值合法时读取，否则忽略该字段。 Sv39 Sv39 支持 39 位虚拟地址空间，$PPN[2]+PPN[1]+PPN[0]+offset=26+9+9+12=56$ 位物理地址空间，最多三级页表，此时每个页的大小为 4KiB（4096 Bytes），共$2^{27}$页。 虚拟地址和物理地址结构如下： 虚拟页大小和物理页相同，每页都是 4096 字节，因此页内偏移必须是$0 - 4095$，占据虚拟地址低 12 位。一个页表项占 8Bytes，一个页表共有 512 项（可表示 VPN 9 位），所有页表大小相同，三级页表共 27 位 VPN，配合 12 位 offset，总共 39 位虚拟地址。 页表项包含下一级页表起始地址或虚拟页对应的物理页的起始地址，但不会直接将完整物理地址写进去，这样占用空间太大了，通常要求页表物理地址 4K 对齐（即起始地址的低 12 位全为 0），省去页内偏移，用剩余的空间存放标志位。Sv39 页表项（PTE）结构如下： 从低位往高位每个域的说明如下： 标志位 意义 RSW 供操作系统使用，硬件会忽略 D(Dirty) 自上次清除 D 位以来页面是否被弄脏（如被写入） A(Access) 自上次清除 A 位以来页面是否被访问 G(Global) 是否对所有虚拟地址均有效，通常用以标记内核的页表，本实验不使用 U(User) 是否是用户所有的页。U = 1 则只有 U-mode 可访问，而 S 模式不能，否则只有 S-mode 可访问 X(eXecutable) 结合 U 位判断当前状态是否可执行 W(Writable) 结合 U 位判断当前状态是否可写 R(Readable) 结合 U 位判断当前状态是否可读 V(valid) 有效位。若 V = 0，表示该页不在物理内存中，任何遍历到此页表项的虚址转换操作都会导致页错误 此外如果 R、W 和 X 位都是 0，那么这个页表项是指向下一级页表的指针，否则它是页表树的一个叶节点。此时它们可以有个特殊用法——实现大页模式。当中间某级页表 RWX 位不均为 0 时，CPU 将直接提取出 PTE 中的物理地址，不再考虑下级页表。利用这个特性，将一级页表中的 PTE RWX 某一位置位，一个 PTE 就可以映射 1GiB 地址空间，将二级页表中的 PTE RWX 某一位置位，一个 PTE 就可以映射 2MiB 地址空间。 从上面的表可以看到，RISC-V 的权限控制非常严格，U-mode 只能访问“用户态”（U 位置位）的页，S-mode 只能访问“内核态”的页。有时确实需要在内核态读取用户态进程所有的页，RISC-V 虽然默认不允许，但仍然为操作系统开了后门。当置位 status 寄存器中的 SUM 位时，可以在 S-mode 访问“用户态”页。 在一些页面置换算法中，操作系统依赖 A 位和 D 位决定交换哪些页面到辅存。定期清除 A 位有助于 OS 判断哪些页面是最近最少使用的（请参考改进的 Clock 算法）。由于需要写入辅存，置上 D 位的页面换出成本更高。 关于虚拟分页的基础介绍就先到这里，若有其余需要补充的知识将会在后续章节里补充。 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"virtualmm/header.html":{"url":"virtualmm/header.html","title":"基础头文件准备","keywords":"","body":" By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"virtualmm/init.html":{"url":"virtualmm/init.html","title":"初始化过程","keywords":"","body":"虚拟分页的初始化过程 我们的任务 内存管理的一切少不了操作系统的参与，其中最重要的任务之一便是维护每个进程的页表。在我们创建用户进程之前，只有从开机便一直持续运行的内核代码，因此我们的总体思路是先为内核区做一个页表，随后将一级页表的物理地址和分页方案写入 satp 寄存器，最后刷新 TLB，虚拟分页就可成功开启。 虚拟内存布局规划 在建立页表之前，需要首先规划虚拟内存布局，决定存放内核的虚拟内存空间。考虑这样一个前提：虚拟内存的作用之一就是让进程认为自己独占了整了内存，除此之外为了便于调用系统函数，内核部分也需要在虚拟内存地址空间中有所体现，因此虚拟内存的布局中只有系统内核和当前进程的代码与数据。RISC-V Reader Chinese v2.1 第 48 页的图 3.10 展示了一个典型的 RISC-V 程序分配给代码和数据的内存区域，我们就参考这个布局，在虚拟内存后部加上供存放内核的位置即可，最后我们采用的布局如下： 0xFFFFFFFF----->+--------------+ | | | Kernel | | | 0xC0000000----->---------------+ | Hole | 0xBFFFFFF0----->---------------+ | Stack | | + | | | | | v | | | | ^ | | | | | + | | Dynamic data | brk----->+--------------+ | | | Static data | | | +--------------+ | | | Text | | | 0x00010000----->---------------+ | Reserved | 0x00000000----->+--------------+ 栈从 0xBFFFFFF0 向低地址扩张，因随后即将采用页面大小为 1 GiB 的大页模式，0xC0000000 恰好是栈空间往上最近的与 1 GiB 对齐的起始地址，留给内核的空间较大。 内核占据虚拟地址空间的 0xC0000000 到 0xFFFFFFFF ，对应的物理内存空间是 0x80000000 到 0x88000000 ，内核的起始物理地址和虚拟物理地址恰好相差 0x40000000 ，得到虚拟地址和物理地址之间的转换关系： VirtualAddress=PhysicalAddress+LinearOffsetVirtualAddress = PhysicalAddress + LinearOffsetVirtualAddress=PhysicalAddress+LinearOffset 内核虚拟地址空间就是可用物理内存地址空间的线性映射： VirtualAddressSpace[0xC0000000,C8000000)⟶PhysicalAddressSpace[0x80000000,88000000) VirtualAddressSpace[0xC0000000,C8000000) \\longrightarrow PhysicalAddressSpace[0x80000000, 88000000) VirtualAddressSpace[0xC0000000,C8000000)⟶PhysicalAddressSpace[0x80000000,88000000) 为了便于后续程序编写，可以编写内核区物理地址与虚拟地址相互转换的宏来表示这一线性映射关系： // include/mm.h #define LINEAR_OFFSET 0x40000000 #define PHYSICAL(vaddr) (vaddr - LINEAR_OFFSET) #define VIRTUAL(paddr) (paddr + LINEAR_OFFSET) 在启用分页机制之前，内核程序入口点在 0x80200000，转换为虚拟地址后变成 0xC0200000。链接脚本中各节存放的地址也应以虚拟地址为准，这样才能使编译出来后各符号的内存地址是 0xC020****，保证在开启分页机制之后所引用的变量与函数的地址的正确性： /* 目标架构 */ OUTPUT_ARCH(riscv) /* 执行入口 */ ENTRY(_start) /* 起始地址 */ BASE_ADDRESS = 0xc0200000; 这样，可执行文件中的地址全部大于 0xC0200000，我们确保了可执行文件中的地址与规定的虚拟地址空间一致。 这时候可能会有疑惑，为什么如此一来 SBI 启动到 0x80200000 还可以正确执行呢？ 因为我们在启动 QEMU 时参数 addr=0x80200000 将内核的代码确确实实地加载到了物理内存的 0x80200000，并且在内核启动后到分页开启前的过程中使用的都是相对寻址，没有引用符号的绝对地址寻址，只要偏移正确，程序自然就能在当前 pc 的基础上向前或向后继续执行。而当前 pc 是在 0x8020**** 这一段上，未开启分页时所有的地址都是物理地址，而物理地址的这一部分存放的也确实是内核初始化代码，所以不会有问题。 开启大页模式虚拟内存 写入页表 设计分页方案时有一个问题，我们内核的代码编译后已经远大于 4KiB（一页）了，即使现在没有，以后也会发生，如果让我们手动往内存里一行一行写一整个内核的页表的话，既费时且没有灵活性，每次内核大小的增长都将导致页表需要重新编写。因此我们需要灵活简便的页表生成方式，这里我们采取一种策略：进入内核后通过内核生成 Sv39 的三级页表。 这有两种实现的方式： 先使用 1GiB 的大页模式来映射整个物理内存到虚拟内存，随后开启分页，依靠系统代码逐一生成小页表后再重新设置 satp 寄存器，刷新 TLB。 进入系统后直接在使用物理地址环境下生成小页表，将一级页表写入 satp 寄存器，刷新 TLB。 这里我们采用第一种方案，相对的比较灵活自由，第二种方案由同学们自己考虑可行性与实现方法。 开启分页 开启分页并不难，只需要将页表地址和分页方案写入 satp 寄存器即可，在那之前，我们还得构造一个页表，回顾一下上一节 Sv39 的页表项结构，按照上面所讲的内容，我们构造如下线性映射： VirtualAddressSpace[0xC0000000,C8000000)⟶PhysicalAddressSpace[0x80000000,88000000) VirtualAddressSpace[0xC0000000,C8000000) \\longrightarrow PhysicalAddressSpace[0x80000000, 88000000) VirtualAddressSpace[0xC0000000,C8000000)⟶PhysicalAddressSpace[0x80000000,88000000) 那么 PTE 中每一项需要填写的内容就是 Reserved: 0000 0000 00b PPN[2]: 0x8000 0000h >> (12 + 9 + 9) PPN[1]: 0 0000 0000b（随意填） PPN[0]: 0 0000 0000b（随意填） RSW: 00b（随意填） D: 0b A: 0b G: 0b（随意填） U: 0b X: 1b W: 1b R: 1b V: 1b 组合起来用算术表示就是 $((0x80000000 >> 30) > 2) | 0x0F$ 虚拟内存是 0xC0000000，向右移动 12 + 9 2 = 30 位可得 3，表示此条页表项应该放在一级页表下标为 3 的位置（即第 4 条），需要在这条映射之前放 3 条无效（V = 0）的页表项。页表项每条占 64 bits，即 8 Bytes，我们使用汇编伪操作 `.zero 3 8来实现，.zero N` 表示填充 N 个字节的 0，当一条页表项全为 0，那么 V 位一定是 0，可以很方便实现无效页表项的填充。 每个页表有 512 项，因此后面还有 508 条无效页表项需要填充，同样使用 .zero 508 * 8 完成。 页表就这么建完了。.. 吗？ 显然没有，考虑一下当我们建完页表，填写完 satp 寄存器开启虚存之后，我们的 pc 在哪？没错，pc 仍然停留在 0x8020**** 这一段，但我们已经开始用页表了，这一虚拟地址的对应项在页表里是无效的（V = 0），因此继续执行的话，从 pc 所指虚拟地址取指会出现错误，我们还需建一条页表项，让虚拟地址 0x80000000 映射到物理地址 0x80000000 处。 模仿上面的算法，我们要在页表第 3 条同样写入 .quad (0x80000000 >> 2) | 0x0F，因此最后页表在 entry.S 中是这样的： boot_pg_dir: .zero 2 * 8 .quad (0x80000000 >> 2) | 0x0F .quad (0x80000000 >> 2) | 0x0F .zero 508 * 8 为什么我把这个映射删了，代码还是可以运行？因为 QEMU 有指令缓存，实际上这样的删去的写法是错误的。尝试在 sfence.vma 后加入指令 fence.i 即可发现运行失败。 在构建好页表之后，我们就可以把页表加载到 satp 寄存器中，这样我们就可以在虚拟地址 0xC0000000 处执行 pc 指向的指令了。 我们再来回顾一下 satp 寄存器的结构： 低 44 位是一级页表的物理页号（物理地址 satp，最后刷新 TLB 即可，代码如下： _start: la t0, boot_pg_dir srli t0, t0, 12 li t1, (8 设置栈顶指针并进入 main 函数 虚拟分页开启成功了，接下来再设置栈顶指针，随后跳转到我们写的 main 函数即可，也许会觉得沿用前面实验的代码无需修改，然而不是这样的。 前面的代码使用短短两行 la sp, boot_stack_top call main 就实现了。但是当我们如此写上之后会发现最后无法完全正确执行，为什么呢？我们使用 riscv64-unknown-elf-objdump -d kernel.bin >> disassembly.s 把生成的 kernel.bin 文件反汇编一下，可以看到我们的 _start 是由如下汇编代码构成的： 00000000c0200000 : c0200000: 00004297 auipc t0,0x4 c0200004: 00028293 mv t0,t0 c0200008: 00c2d293 srli t0,t0,0xc c020000c: fff0031b addiw t1,zero,-1 c0200010: 137e slli t1,t1,0x3f c0200012: 0062e2b3 or t0,t0,t1 c0200016: 18029073 csrw satp,t0 c020001a: 12000073 sfence.vma c020001e: 0000e117 auipc sp,0xe c0200022: fe210113 addi sp,sp,-30 # c020e000 c0200026: 004000ef jal ra,c020002a 上面两行代码在汇编器汇编后会生成如下代码： c020001e: 0000e117 auipc sp,0xe c0200022: fe210113 addi sp,sp,-30 # c020e000 c0200026: 004000ef jal ra,c020002a 实际上，汇编器见到 la 后会算出 boot_stack_top 与当前 pc 的偏移，随后生成 auipc 与 addi 的组合指令，指令的功能就是把这个偏移加上 pc 后赋值给目标寄存器（此处为 sp）。 那么这个偏移是怎么算的呢？汇编器看到符号表，知道 boot_stack_top 在内存中的地址是 0xc020e000，当前这行指令地址应该是 0xc020001e，这样就可以算出偏移了，这个偏移是 0xc020e000 - 0xc020001e，也就是 0xe000 - 0x1e，拆成两部分组合成了 auipc 与 addi 的组合指令（我们确实能在上面的反汇编代码中看到 0xe 与 0x1e 的十进制 30），通过它们加上 pc 赋值给 sp。 但是等等，汇编器认为当前这行指令地址应该是 0xc020001e，而实际上在开启分页后，pc 依然保留在 0x8020001e，这就导致 pc 加上偏移之后，sp 变成了 0x8020e000，这与虚存地址差了 0x40000000。因此，我们需要手动加上 0x40000000，这样就可以把 sp 变成 0xc020e000，这才符合栈在虚存中的位置。 跳转到 main 函数也是同理，这里就不再赘述。注意不要被反汇编得到的 jal ra,c020002a 欺骗了以为是跳转到 0xc020002a，实际上将指令码 004000ef 和 RISC-V Reader Chinese v2.1 对照一下就能发现实际上是 pc += 4，你会发现似乎能正确进入 main 函数，但是不能执行完所有代码，想想原因？可能是后面长跳转时记录的返回地址还是 0x8020**** ，导致返回出错，也可能是长跳转的目标地址本身就错了，总之 main 函数的跳转还是要加上 0x40000000 的偏移。 最终我们写出来的正确代码是这样的： li t1, 0x40000000 la sp, boot_stack_top add sp, sp, t1 la t0, main add t0, t0, t1 jr t0 整个 entry.s 加上标签与其余的伪代码，完整代码就是 .globl boot_stack, boot_stack_top, _start, boot_pg_dir .section .text.entry # 本项目所用代码模型为 medany, 该代码模型下编译器生成的代码以 PC 相对寻址的方式访问任意地址，地址通过 auipc 和 addi 指令获取。 # 可执行文件中的地址与加载后的内存地址相差 0x40000000，因此处理器访问到的地址加 0x40000000 才是可执行文件中符号的地址。 _start: la t0, boot_pg_dir srli t0, t0, 12 li t1, (8 > 2) | 0x0F .zero 508 * 8 前面提到，全局变量、函数的地址在编译时已经确定，我们这里取到的地址的值应该与 readelf 读取到的地址完全一样，但实际上并非如此。符号的地址是固定的，取地址的方式却有多种，取决于编译使用的代码模型和编译选项。 假设程序中有一个变量global，地址是 1000，编译器生成访问global的代码时有多种选择： 硬编码地址：直接将地址 1000 写死到程序中 PC 相对寻址：将global地址到访问它的指令地址的差值 Offset 写入程序中，通过 PC + Offset 获取地址 1000, 位置无关代码：将global的地址存放到某个固定的地址中，访问时加载器查找global的地址并将其写入，程序从这个地址取出（通常是 PC 相对寻址）global的地址，再读写global。 位置无关代码一般用于动态链接的可执行文件，某些 Linux 发行版上的 GCC 在编译时加入了特定的参数，总是生成位置无关可执行文件，为了确保所有的地址都通过 PC-relative 寻址获取。本内核使用 medany 代码模型，并使用 -fno-pie 禁止生成位置无关可执行文件。 从大页到小页 我们的新任务 main 函数的代码沿用上一个实验的代码不变，但是 mem_init() 函数和 mem_test() 函数肯定需要有所变化。 在 mem_init() 初始化完物理内存的管理之后，我们就需要开始建立 Sv39 的三级页表，即进入小页模式。整体的规划就是先分配一个空闲物理页，随后把它作为一级页表，建立二、三级页表，建立内核部分虚拟内存到物理内存的完整映射，最后激活新的页表即可。 我们先设置一个全局变量 pg_dir 指向当前页目录（一级页表）的虚拟地址，并且赋值指向先前建立的大页页表，之后所有和页表有关的函数，都通过 pg_dir 来处理页表。 因此我们可以写出如下代码框架： /* 进入 main() 时开启了 SV39 大页模式，暂时创造一个虚拟地址到物理地址的映射让程序跑起来。 * 现在，我们要新建一个页目录并开启页大小为 4K 的 SV39 分页。*/ uint64_t page = get_free_page(); assert(page, \"mem_init(): fail to allocate page\"); pg_dir = (uint64_t *)VIRTUAL(page); map_kernel(); active_mapping(); 有了这样一个框架，我们要做的自然就是补全其中的函数。上面的 get_free_page() 函数是上一个实验所讲内容，不再赘述。 建立内核的内存映射 在这里我们需要完善 map_kernel() 函数，映射内核物理内存有两个部分需要考虑： 真实的内存所在地址空间 物理地址空间：[MEM_START, MEM_END) 虚拟地址起始处：KERNEL_ADDRESS 标志位：为方便内核访问，设为内核态可读可写可执行且有效 KERN_RWX | PAGE_VALID 设备 MMIO 地址空间 物理地址空间：[DEVICE_START, DEVICE_END) 虚拟地址起始处：DEVICE_ADDRESS 标志位：内核态可读可写且有效 KERN_RW | PAGE_VALID 我们用函数 map_pages() 来完成： /** * @brief 建立所有进程共有的内核映射 * * 所有进程发生系统调用、中断、异常后都会进入到内核态，因此所有进程的虚拟地址空间 * 都要包含内核的部分。 * * 本函数仅创建映射，不会修改 mem_map[] 引用计数 */ void map_kernel() { map_pages(DEVICE_START, DEVICE_END, DEVICE_ADDRESS, KERN_RW | PAGE_VALID); map_pages(MEM_START, MEM_END, KERNEL_ADDRESS, KERN_RWX | PAGE_VALID); } 随后便是实现 map_pages() 函数，使用循环从物理地址空间从头循环到尾，利用 put_page() 对地址空间内的每一页，都建立其虚拟地址到物理地址的映射，即创建页表，填写对应的页表项： /** * @brief 将物理地址区域映射到虚拟地址区域 * * @param paddr_start 起始物理地址 * @param paddr_end 结束物理地址 * @param vaddr 起始虚拟地址 * @param flag PTE 标志位 * @note * - 地址必须按页对齐 * - 仅建立映射，不修改物理页引用计数 */ static inline void map_pages(uint64_t paddr_start, uint64_t paddr_end, uint64_t vaddr, uint8_t flag) { while (paddr_start 在层层封装之后，我们终于来到最内层，要实现 put_page() 函数了。函数创建映射的过程就是遍历页表，若页表不存在就创建，直到最后一级页表，在遍历过程中将物理页号和标志位写进 PTE。 在映射之前我们首先要判定物理地址是否按页对齐 即某物理地址是否能作为一页的开始，不按页对齐无法使用页表项来表示映射。 根据虚拟地址空间起始地址获取三级虚页号。 从页目录开始，以虚页号为索引，查询在第一、第二级页表中对应的页表项是否有效（不存在即为 0）。若无效，则申请一页空闲物理页用于存放下一级页表，并将其物理地址写入页表项，将有效位置位。随后根据当前页表项进入下一级页表，重复 3 将第三级页表的页表项的物理地址域设置为待映射的物理地址，标志位设置为给定标志位 返回完成映射的物理地址（这一返回值暂未被使用，为以后预留） 注意：第三步中，根据当前页表项进入下一级页表时，需要将页表项中的物理页号扩展到完整物理地址并转成虚拟地址，因为虽然 CPU 的 MMU（内存处理单元）每次读取下一级页表地址时将其视作物理地址，但是我们这里是人工访问这一地址，并未借助 MMU 自动处理页表的机制，且整个系统已经开启了虚拟分页，所有访问的地址都是按照虚拟地址处理，所以将其转为虚拟地址后才能访问到正确位置。 代码如下，其中 tmp >> 2 是 tmp >> 12 的缩写，原因请参考 页表项 的格式，page >> 2 同： /** * @brief 建立物理地址和虚拟地址间的映射 * * 本函数仅仅建立映射，不修改物理页引用计数 * 当分配物理页失败（创建页表）时 panic，因此不需要检测返回值。 * * @param page 物理地址 * @param addr 虚拟地址 * @param flag 标志位 * @return 物理地址 page * @see panic(), map_kernel() */ uint64_t put_page(uint64_t page, uint64_t addr, uint8_t flag) { assert((page & (PAGE_SIZE - 1)) == 0, \"put_page(): Try to put unaligned page %p to %p\", page, addr); uint64_t vpns[3] = { GET_VPN1(addr), GET_VPN2(addr), GET_VPN3(addr) }; uint64_t *page_table = pg_dir; for (size_t level = 0; level > 2) | PAGE_VALID; } page_table = (uint64_t *)VIRTUAL(GET_PAGE_ADDR(page_table[idx])); } page_table[vpns[2]] = (page >> 2) | flag; return page; } 激活新页表 激活新页表就很简单了，我们要做的就是重新填写 satp 寄存器并刷新 TLB，具体代码可以参考 entray.s 中的写法与 lab1 中内联汇编的写法。 不过在这里，我们也顺便置位 status 寄存器 SUM 标志位，允许内核读写用户态内存，为之后的用户态进程创建做准备。 我们给了内核读写用户态内存的特权，这样做可能会导致一定的安全问题，但方便了应用态和内核态之间的数据传送。 至此，我们从物理地址过渡到了虚拟地址。 /** * @brief 激活当前进程页表 * @note 置位 status 寄存器 SUM 标志位，允许内核读写用户态内存 */ void active_mapping() { __asm__ __volatile__(\"csrs sstatus, %0\\n\\t\" \"csrw satp, %1\\n\\t\" \"sfence.vma\\n\\t\" : /* empty output list */ : \"r\"(1 > 12) | ((uint64_t)8 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"virtualmm/manage.html":{"url":"virtualmm/manage.html","title":"其他管理过程","keywords":"","body":" [ ] 介绍其余相关函数 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"process/":{"url":"process/","title":"进程管理","keywords":"","body":"进程管理 进入这一章之后，我们会来实现一些与进程相关的工作，包括进程的创建、调度、终止等。同时我们还将会涉及到一些比较简单的进程间的通信，如信号等。 在此之前，我们的内核都是运行在拥有非常高权限的 S 态，不曾对特权级做过切换。而进程运行在用户态(对应 RISC-V 的 U 态)，只有在发生中断后才会进入内核态由内核代为完成一部分任务，这样可以隔离用户进程与系统内核，避免用户进程对系统或其他进程的破坏，因此本章的内容还会涉及特权级切换与系统调用的相关内容，并对中断处理过程做少许修改。 本章对应代码：lab5 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "},"process/task0_init.html":{"url":"process/task0_init.html","title":"初始化 0 号进程","keywords":"","body":"用户栈与内核栈 在进程运行在用户态时，发生的函数调用都是由进程内部自己产生的，因此函数的调用栈也是由进程自己管理，此时的栈上存储的内容与进程的活动有关。 当发生中断时，进程的活动将会被暂停，由操作系统内核接管完成操作，此时栈上存储的内容与内核的活动有关。因此在这两种不同的特权级下，每个进程都需要有两个互不干扰的栈，以避免进程/内核对栈进行操作时影响内核/进程的状态。另外，同一个进程在内核态与用户态使用同一个页表，使用两段独立内存空间也避免了某一特权级对栈内存缺少访问权限。 切换栈的操作并不会由 CPU 自动完成，我们需要在特权级切换的时候一并完成栈的切换。在用户态发生特权级切换一定是因为发生了中断，因此我们在中断处理程序中对栈完成切换。在中断处理的过程中，有一个 sscratch 寄存器是 CPU 提供用于暂存一个字大小的数据的，因此我们可以将它拿来存放栈地址并指示当前处于何种特权级，我们规定： 处于 U 态时，sscratch 保存内核栈地址（sp 保存用户栈地址） 处于 S 态时，sscratch 为 0（sp 保存内核栈地址，用户栈地址存放于内核栈上）。 中断发生 我们在保存上下文之前不可随意修改通用寄存器，以免数据丢失。因为 CSR 寄存器不可直接使用条件判断指令，需要读出至通用寄存器判断，所以我们首先将 sscratch 与 sp 交换，随后通过 sp 的值判断中断发生前处于何种状态。 若中断前是内核态，则将 sscratch 值（交换后为 sp 的值，即中断发生前的内核栈地址）重新读回 sp 此时 sp 为内核栈地址，sscratch 也为内核栈地址 若中断前是用户态，不作处理 此时 sp 为内核栈地址，sscratch 为用户栈地址 随后和前面的实验一样，扩张内核栈空间（模拟压入栈），保存所有通用寄存器的值至内核栈上，除了 x2（即sp）寄存器，sp 本应保存的是发生中断前的值，这个值目前被交换到了 sscratch 中，因此留到后面处理。 在保存完所有通用寄存器后，这些寄存器已可被随意使用，此时读取 sscratch 到 s0，再赋 sscratch = 0（在内核态中，需要确保 sscratch 为 0，借 s0 中转 sscratch 内的中断前栈地址存至内核栈上）。同样的，借 s1 至 s4 寄存器中转其他需要的 CSR 寄存器至内存中，方便后续读取。 SAVE_ALL 宏完整代码如下： # 定义宏：保存上下文（所有通用寄存器及额外的CSR寄存器） # 我们规定：当 CPU 处于 U-Mode 时，sscratch 保存内核栈地址；处于 S-Mode 时，sscratch 为 0 。 .macro SAVE_ALL # 交换 sp 和 sscratch 寄存器 csrrw sp, sscratch, sp # 可以通过sp是否为0判断原先是否为内核态 # 如果中断来自用户态，此时 sp 已经指向内核栈，直接跳转到 trap_from_user 保存寄存器 bnez sp, trap_from_user # 否则为0，原本就是内核态，再次交换，继续往下执行，保存上下文 trap_from_kernel: # 将sscratch中的值读到sp中，此时 sscratch = 发生中断前的 sp（内核栈） csrr sp, sscratch # 不为0，原本是用户态，不做交换，直接保存上下文 trap_from_user: # 将栈指针下移为TrapFrame预留足够的空间用于将所有通用寄存器值存入栈中（36个寄存器的空间） addi sp, sp, -36*XLENB # 保存所有通用寄存器，除了 x2 (x2就是sp，sp 本应保存的是发生中断前的值，这个值目前被交换到了 sscratch 中，因此留到后面处理。) STORE x1, 1 STORE x3, 3 STORE x4, 4 STORE x5, 5 STORE x6, 6 STORE x7, 7 STORE x8, 8 STORE x9, 9 STORE x10, 10 STORE x11, 11 STORE x12, 12 STORE x13, 13 STORE x14, 14 STORE x15, 15 STORE x16, 16 STORE x17, 17 STORE x18, 18 STORE x19, 19 STORE x20, 20 STORE x21, 21 STORE x22, 22 STORE x23, 23 STORE x24, 24 STORE x25, 25 STORE x26, 26 STORE x27, 27 STORE x28, 28 STORE x29, 29 STORE x30, 30 STORE x31, 31 # 保存完x0-x31之后这些寄存器就可以随意使用了，下面马上用到： # 读取sscratch到s0，赋 sscratch = 0（在内核态中，时刻保持sscratch为0，让s0存原有的sp） csrrw s0, sscratch, x0 # 读取 sstatus, sepc, stval, scause寄存器的值到s0-s4（x1-x31中的特定几个）寄存器 csrr s1, sstatus csrr s2, sepc csrr s3, stval csrr s4, scause # 存储 sp, sstatus, sepc, sbadvaddr, scause 到栈中 # 其中把s0存到x2（sp）的位置以便于返回时直接恢复栈 STORE s0, 2 STORE s1, 32 STORE s2, 33 STORE s3, 34 STORE s4, 35 .endm 中断恢复 在中断处理程序结束时，需要恢复上下文与特权级。首先从内存中读入中断发生时 sstatus 与 sepc 的值至通用寄存器。 我们可以借助 sstatus.SPP 是否为 1 来判断中断前的特权级，1为内核态，0为用户态。 若回到用户态，则需要将发生中断前的内核栈地址（sp 扩张前的值，模拟弹出栈）重新存入 sscratch 以符合我们的规定。 若回到内核态，则跳过这一步，保持值为 0。 随后从通用寄存器中将中断发生时 sstatus 与 sepc 的值读至 sstatus 与 sepc 寄存器。 恢复通用寄存器时因为 LOAD 宏使用了扩张后的栈地址 sp，因此同样将 sp 留到最后恢复，最后执行 sret 从内核态中断返回。 RESTORE_ALL 宏完整代码如下： # 定义宏：恢复寄存器 .macro RESTORE_ALL LOAD s1, 32 # s1 = sstatus LOAD s2, 33 # s2 = sepc andi s0, s1, 1 系统调用 从用户态主动进入内核态的方式就是通过系统调用进行。它在指令集层面的实现原理是在 U 态发出 ecall 指令，这时 CPU 会收到一个 CAUSE_USER_ECALL 异常，进入内核态处理异常。 系统调用可以有不定长的参数，参数可以使用寄存器传递，返回值也是用寄存器传递，具体可查看 RISC-V ABI 规范，因此一个系统调用的入口函数可以写成这样： /** * @brief 通过系统调用号调用对应的系统调用 * * @param number 系统调用号 * @param ... 系统调用参数 * @note 本实现中所有系统调用都仅在失败时返回负数，但实际上极小一部分 UNIX 系统调用（如 * `getpriority()`的正常返回值可能是负数的）。 */ int64_t syscall(int64_t number, ...) { va_list ap; va_start(ap, number); int64_t arg1 = va_arg(ap, int64_t); int64_t arg2 = va_arg(ap, int64_t); int64_t arg3 = va_arg(ap, int64_t); int64_t arg4 = va_arg(ap, int64_t); int64_t arg5 = va_arg(ap, int64_t); int64_t arg6 = va_arg(ap, int64_t); int64_t ret = 0; va_end(ap); if (number > 0 && number 同样的，我们还需在中断处理程序中添加对 CAUSE_USER_ECALL 异常的处理，只需在原有的 exception_handler 函数内修改。可以直接调用一个新函数： case CAUSE_USER_ECALL: return syscall_handler(tf); break; 随后在 syscall_handler 函数中分派至不同的系统调用处理函数： /** * @brief 系统调用处理函数 * * 检测系统调用号，调用响应的系统调用。 * 当接收到错误的系统调用号时，设置 errno 为 ENOSY 并返回错误码 -1 */ static struct trapframe* syscall_handler(struct trapframe* tf) { uint64_t syscall_nr = tf->gpr.a7; if (syscall_nr >= NR_syscalls) { tf->gpr.a0 = -1; errno = ENOSYS; } else { tf->gpr.a0 = syscall_table[syscall_nr](tf); } tf->epc += INST_LEN(tf->epc); /* 执行下一条指令 */ return tf; } 初始化 0 号进程 初始化 0 号进程 PCB 所有用户进程都是从 0 号进程 fork 出来的，因此我们需要手动构建 0 号进程所需的相关数据，最主要的就是进程的 PCB。 在这里我们直接构建一个 PCB 的结构体变量，将进程 0 的一部分必要信息填入，并将该 PCB 的地址存入进程数组中，顺便把进程数组的其他进程清空（理论上来说全局变量默认值为 0，不清空也没关系），最后把当前进程设为进程 0： /** * @brief 初始化进程模块 * * 主要负责初始化进程 0 */ void sched_init() { tasks[0] = (struct task_struct*)&init_task; init_task.task = (struct task_struct) { .state = TASK_RUNNING, .counter = 15, .priority = 15, .start_time = ticks /* 0 */, // .start_code = START_CODE, // .start_stack = START_STACK, // .start_kernel = START_KERNEL, // .start_rodata = (uint64_t)&rodata_start - (0xC0200000 - 0x00010000), .start_data = (uint64_t)data_start - ((uint64_t)kernel_start - START_CODE), .end_data = (uint64_t)kernel_end - ((uint64_t)kernel_start - START_CODE), .brk = (uint64_t)kernel_end - ((uint64_t)kernel_start - START_CODE), .pg_dir = pg_dir, }; current = &init_task.task; } 现在我们有三个地址空间： 物理地址空间： 物理内存在 0x80000000 往后的空间，其中 0x80000000 - 0x80200000 属于 SBI，0x80200000 起属于系统部分 进入用户态（执行 init_task0）之前的虚拟地址空间： 内存空间从 0xC0000000 开始，其中 0xC0000000 - 0xC0200000 属于 SBI，0xC0200000 起属于系统部分 进入用户态（执行 init_task0）之后的虚拟地址空间： 从 0x10000 起属于用户代码段部分，随后依次是静态数据区、动态数据区以及用户栈 内核内存空间从 0xC0000000 开始，其中 0xC0000000 - 0xC0200000 属于 SBI，0xC0200000 起属于系统部分 可以看到在 PCB 中，进程 0 的内存布局（数据段的起始地址与数据段、堆的结束地址）和页表（暂时沿用内核的页表，将在 0 号系统调用中被重新映射）已经被指定。 这里的 init_task 结构体是个全局变量，不能使用局部变量，以避免因函数结束导致变量生命周期结束。 切换至用户态 创建完进程 0 的相关数据结构并切换到进程 0 之后，我们需要将特权级切换至 U 态（以下也成用户态，不做区分），这里采用伪造中断发生的方法来实现。 我们假设，我们正运行在用户态，sscratch 按照规定设置为内核栈地址。此时通过 ecall 指令陷入内核态请求一个系统调用，这时候 CPU 会自动将部分寄存器改写： scause: 被设置成 CAUSE_USER_ECALL sstatus: SPP 位设为发生异常之前的权限模式（0，表示 U 态） SIE 位置 0 以禁用中断 SPIE 位被设置为原 SIE 位的值（1，开） sepc: 被设置为异常发生时的 pc 值 pc: 被设置为 stvec(__alltraps) 因此我们要想伪造一个从用户态发出的系统调用，我们就需要伪造上述 CSR 的变化。此外，由于系统调用至少需要一个参数提供调用号，而我们不是通过真正执行 syscall 函数进入系统调用的，因此我们也需要伪造这个参数，这里我们需要提前写好一个系统调用处理函数，并绑定系统调用号（0号）。 我们可以直接将值写入各寄存器后用 call 指令跳转至 __alltraps 处，避免函数调用影响栈。 整个 init_task0 函数都是在伪造这一过程： /** * @brief 初始化进程 0 * 手动进入中断处理，调用 sys_init() 初始化进程0 * @see sys_init() * @note 这个宏使用了以下三个 GNU C 拓展： * - [Locally Declared Labels](https://gcc.gnu.org/onlinedocs/gcc/Local-Labels.html) * - [Labels as Values](https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html) * - [Statements and Declarations in Expressions](https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html#Statement-Exprs) */ #define init_task0() \\ ({ \\ __label__ ret; \\ write_csr(scause, CAUSE_USER_ECALL); \\ clear_csr(sstatus, SSTATUS_SPP); \\ set_csr(sstatus, SSTATUS_SPIE); \\ clear_csr(sstatus, SSTATUS_SIE); \\ write_csr(sepc, &&ret - 4 - (SBI_END + LINEAR_OFFSET - START_CODE)); \\ write_csr(sscratch, (char*)&init_task + PAGE_SIZE); \\ register uint64_t a7 asm(\"a7\") = 0; \\ __asm__ __volatile__(\"call __alltraps \\n\\t\" ::\"r\"(a7):\"memory\"); \\ ret: ; \\ }) 其中较为复杂的部分是 sepc 和 sscratch 值的确定。 内核栈的设定 我们现在用的内核栈是在系统启动时临时设置的初始栈，位于 boot_stack 至 boot_stack_top 之间，当引入进程后，每个进程的内核栈不同，需要为每个进程都开辟一个新的内核栈。这里我们设定 PCB 所在的页同时用作内核栈使用，PCB 存于该页低地址处，而内核栈从该页高地址处往低地址增长。sscratch 值在中断发生前存的是内核栈地址，同样需要对其进行“伪造”。 返回地址的设置 模拟中断返回时应该是返回到中断发生前的下一条语句，由于我们不知道编译完成后 call __alltraps 的下一条指令的地址，我们在这里定义一个标签，随后便可以使用 && 运算符获取其地址。这里的获取到地址根据链接脚本来确定，在 0xc02000** 段，但是之后的代码在用户态的虚拟内存地址映射中并不是处于 0xc02000** 段，因此我们还需要对它稍加运算，获得真正的在用户态的虚拟地址值。 0 号系统调用 在 0 号系统调用中，我们主要完成与进程 0 内存相关的部分，如新页表的映射与启用、用户栈的分配。 通过页表映射用户进程各段 对于用户进程，由于每一个段的权限都不同，因此需要被单独映射。 由于我们并没有实际上的 0 号进程的代码和数据，我们将内核的代码和数据映射至用户程序的内存空间，当做 0 号进程的代码和数据使用。从 linker.ld 文件可知，我们的代码与数据主要分为四段，依次为： 代码段(text)： 从 text_start 到 rodata_start 用户态只读和执行 只读数据段(rodata)： 从 rodata_start 到 data_start 用户态只读 数据段(含 data 与 bss 段)： 从 data_start 到 kernel_end 用户态可读可写 请注意，这里仅仅是把内核的代码和数据充当进程 0 的代码和数据，并不取消原内核内存空间的映射。相当于两个虚拟地址映射到同一段物理地址上，因此在新映射建立后物理页的引用计数需要加 1. 可以写一个函数循环调用 put_page 函数以方便映射段。注意两端虚拟地址的差值，同时做好物理内存页面引用计数的管理： /** * @brief 创建进程 0 各段的映射 * * @param start 虚拟地址起始 * @param end 虚拟地址结束 * @param flag 权限位 */ static void map_segment(uint64_t start, uint64_t end, uint16_t flag) { uint64_t physical = PHYSICAL(start); start -= VIRTUAL(SBI_END) - START_CODE; end -= VIRTUAL(SBI_END) - START_CODE; while (start != end) { put_page(physical, start, flag); start += PAGE_SIZE; ++mem_map[MAP_NR(physical)]; physical += PAGE_SIZE; } } 分配用户栈 随后我们先分配一页空间作为进程的用户态栈（若以后不够用可以通过页错误异常处理程序自动扩张），刷新 TLB，并将现内核态栈（地址存于 sp 寄存器）的数据复制过去，最后将上下文中的栈指针（sp 与 s0）设置为用户栈地址，这样返回用户态时恢复上下文后就能使用新的用户栈了。 完成这些任务后，将“伪”中断中保存的上下文数据地址存入 PCB 中，以备后续 switch_to 函数使用。 我们规定栈顶从 0xBFFFFFF0 开始向低地址扩展，因此我们需要在虚拟地址 START_STACK - PAGE_SIZE 处申请新页，并且是用户态可读可写，可以使用 get_empty_page 函数完成。 注意：sp 理论上不能仅简单设置为 START_STACK，因为从内核栈复制过来的用户栈已经有有用的数据（如局部变量）了，新的内容不能将原有数据覆盖，而是需要在原有数据基础上收缩/扩张栈，需要使用原 sp 加上用户栈到初始栈的偏移量。 同样需要注意的是这里参与计算的 sp 值不能是当前 sp 寄存器的值，因为在进入“伪”中断后 sp 由于需要存放上下文被修改过，内核栈在中断返回时会被恢复，但 tf 中的我们手动修改的用户栈并不会，这样回到用户态后栈上会有多余的“伪”中断时的保存的上下文。 GCC 使用 s0 寄存器来查找栈上的局部变量，它指向当前栈帧起始地址（高地址），和 sp 一样需要加上用户栈到初始栈的偏移量来使用户态程序能在用户栈中查找局部变量。 另外还需注意，复制过来的用户栈中有函数调用信息，但是里面的返回地址（绝对地址）在内核区，用户态无法访问，因此函数调用信息不可被使用，也正因如此，init_task0 不能使用函数调用的方式访问，必须使用宏，并且直接放在 main 函数中，不可由其他函数调用，否则会出现返回至内核区的错误。 可以直接使用在 mm.h 中引入的链接脚本中的符号来确定各个段的起始地址： /** * @brief 初始化进程 0 * * 创建用户态进程零，将内核移入进程中。 * @see init_task0() * @note 只有在发生中断时才能保存处理器状态， * 因此让 sys_init() 占据系统调用号 0, * 但是实际上 sys_init() 被内核调用，并 * 不是系统调用。 */ int64_t sys_init(struct trapframe* tf) { /* 创建指向内核代码/数据的用户态映射 */ map_segment((uint64_t)text_start, (uint64_t)rodata_start, USER_RX | PAGE_VALID); map_segment((uint64_t)rodata_start, (uint64_t)data_start, USER_R | PAGE_VALID); map_segment((uint64_t)data_start, (uint64_t)kernel_end, USER_RW | PAGE_VALID); /* * 创建进程 0 堆栈（从 0xBFFFFFF0 开始） * * 内核堆栈已使用的空间远小于一页，因此仅为用户态堆栈分配一页虚拟页。 * 为了确保切换到应用态后正确执行，将内核态堆栈的数据全部拷贝到用用户态堆栈中。 */ get_empty_page(START_STACK - PAGE_SIZE, USER_RW); get_empty_page(START_STACK, USER_RW); invalidate(); memcpy((void*)((uint64_t)START_STACK - PAGE_SIZE), (const void*)FLOOR(tf->gpr.sp), PAGE_SIZE); tf->gpr.sp += START_STACK - (uint64_t)boot_stack_top; /* GCC 使用 s0 指向函数栈帧起始地址（高地址），因此这里也要修改，否则切换到进程0会访问到内核区 */ tf->gpr.s0 += START_STACK - (uint64_t)boot_stack_top; save_context(tf); return 0; } 在完成 0 号系统调用后，CPU 就通过 sret 指令根据第二部伪造的中断进入了用户态，继续执行 main 函数中的语句。 附录 GCC提供一些标准 C 不支持的额外语法与功能，本节附录主要介绍代码中使用到的三个 GNU C 的拓展。 Locally Declared Labels 扩展 局部声明的标签是作用域仅在当前块及嵌套的块、嵌套的函数内的标签，声明方式为__label__ label1, label2, /* … */;。局部标签的声明必须在代码块的开头所有其他普通声明与语句之前。局部标签的声明只声明其名称，具体的定义依然需要靠label:来实现。 在较为复杂的宏中局部标签使用 goto 跳出循环或获取某一地址，用局部标签会更方便，可以避免多次引用这一宏引发的标签重复定义的问题。 使用示例见 sched.h 中 init_task0 宏的定义，其中使用 __label__ ret; 声明了局部标签ret，并在 write_csr(sepc, &&ret - 4 - (SBI_END + LINEAR_OFFSET - START_CODE)); 中使用了它的地址，而 ret 的具体定义在 ret: ; 处。 Labels as Values 扩展 对于当前函数中定义的标签，可以使用 && 运算符获取其地址，获取到的值的类型为 void *，例如： void *ptr; /* … */ ptr = &&foo; 同时你可以用 goto *ptr; 来跳转至该标签所代表的地址。 注意：跨函数使用这一方法跳转会导致不可预知的后果。 在 inline 函数或 clone 函数中，对同一个标签获取到的值可能不同，如果需要保证它们相同，需要使用 __attribute__((__noinline__,__noclone__)) 以避免函数被作为 inline 函数或 clone 函数。如果在静态变量初始值设定中使用 &&foo，则禁止 inline 或 clone。 Statements and Declarations in Expressions 扩展 语句表达式：用括号括起来的复合语句可能在 GNU C 中被当做表达式。因此可以在表达式中使用循环、switch和局部变量。 复合语句是指由大括号包围的一系列语句，因此在上述结构中，圆括号可以包含大括号，例如： ({ int y = foo(); int z; if (y > 0) z = y; else z = - y; z; }) 其中复合语句的最后一句应该是一个表达式，其返回值作为整个结构的值，否则返回类型为 void，并且没有返回值。 这一特性使其在确保宏定义的“安全”中较为有用，可用于确保操作数只运算一次。例如在#define max(a,b) ((a) > (b) ? (a) : (b))的定义中，a 和 b 会被计算两次，如果调用它的运算符有副作用（如++运算符），可能会导致错误的结果，在 GNU C 中，如果知道操作数的类型（这里取int），可以通过如下定义宏来避免此问题： #define maxint(a,b) \\ ({int _a = (a), _b = (b); _a > _b ? _a : _b; }) 比如在如下示例中，max 宏会导致a、b自增两次，而 maxint 宏则不会： int a = 0; int b = 1; int c = max(a++, b++); // int c = ((a++) > (b++) ? (a++) : (b++)); int d = maxint(a++, b++); // int d = ({ // int _a = (a++), _b = (b++); // _a > _b ? _a : _b; // }); 请注意，引入变量声明（例如在 maxint 中）可能会和“主调”函数中原有的变量相互影响产生错误，例如在以下示例中 int _a = 1, _b = 2; int c = max(_a, _b); // int c = ((_a) > (_b) ? (_a) : (_b)); int d = maxint(_a, _b); // int d = ({int _a = (_a), _b = (_b); _a > _b ? _a : _b; }); // 展开后变量定义会导致错误 当我们像下例中递归地使用此模式时，也可能会发生此问题： #define maxint3(a, b, c) \\ ({int _a = (a), _b = (b), _c = (c); maxint (maxint (_a, _b), _c); }) 常量表达式（如枚举常量的值、位域的宽度或静态变量的初始值）中不允许嵌入语句。 如果不知道操作数的类型，就需要使用 typeof 或 __auto_type。 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2023-03-14 01:12:40 "}}